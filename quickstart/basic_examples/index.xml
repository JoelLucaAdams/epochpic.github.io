<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Basic examples | EPOCH</title><link>/quickstart/basic_examples.html</link><atom:link href="/quickstart/basic_examples/index.xml" rel="self" type="application/rss+xml"/><description>Basic examples</description><generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><image><url>/images/logo_hub4b4d6a0f57638acebb5550a80c8c030_9243_300x300_fit_lanczos_2.png</url><title>Basic examples</title><link>/quickstart/basic_examples.html</link></image><item><title>Lasers</title><link>/quickstart/basic_examples/laser.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/quickstart/basic_examples/laser.html</guid><description>&lt;p>EPOCH can support laser sources on the boundaries, with a wide array of spatial
and temporal profiles. These examples provide basic input decks for simulating
lasers in vacuum.&lt;/p>
&lt;h2 id="simple-plane-wave">Simple plane wave&lt;/h2>
&lt;p>This input deck provdies the most basic form of laser. We use uniform spatial
and temporal profiles, and inspect the Poynting flux in the simulation window.
As a typical rule of thumb, allow 20 cells per wavelength to get a good
resolution.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:control
nx = 200
ny = 400
t_end = 100e-15
x_min = 0
x_max = 10e-6
y_min = -10e-6
y_max = 10e-6
stdout_frequency = 100
end:control
begin:boundaries
bc_x_min = simple_laser
bc_x_max = open
bc_y_min = open
bc_y_max = open
end:boundaries
begin:laser
boundary = x_min
intensity_w_cm2 = 1.0e18
lambda = 1.0e-6
end:laser
begin:output
dt_snapshot = 10 * femto
poynt_flux = always
end:output
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="simple_laser.png" alt="Uniform laser">&lt;/p>
&lt;p>As we have specified a time-averaged intensity of $10^{18} \text{ Wcm}^{-2}$, we
expect the Poytning flux to range 0 to $2\times 10^{18} \text{ Wcm}^{-2}$, which
we can see here. Note that, because our laser profile reaches the $y_{min}$ and
$y_{max}$ boundaries, some noise has been introduced here. In practice, these
boundary effects are less of an issue, as simulations are expected to mainly
deal with laser pulses.&lt;/p>
&lt;h2 id="laser-pulse">Laser pulse&lt;/h2>
&lt;p>Using the maths parser, we can create a laser pulse which has a Gaussian profile
in time and space. Here, let the full-width-at-half-maximum of the
spatial and temporal profiles be 5 $\mu m$ and 40 fs respectively for the
intensity $I$ distribution. The profile
keys in the laser block describe modifications to the boundary electric fields,
$E$, and as $I \propto E^2$, the $E$ profile must satisfy&lt;/p>
&lt;p>$ e^{-((y-y_0)/\sigma_y)^2}$, $ e^{-((t-t_0)/\sigma_t)^2}$&lt;/p>
&lt;p>Luckily, this is the same form as the &lt;code>gauss(x,x_0,w)&lt;/code> command in the input deck
&lt;a href="/documentation/code_details/maths_parser.html">maths parser&lt;/a>. We can use&lt;/p>
&lt;p>$\sigma = \frac{FWHM}{\sqrt{2\ln(2)}} $.&lt;/p>
&lt;p>We can let the spatial profile peak at $y=0$. We don&amp;rsquo;t want the laser to peak at
$t=0$, as this would ignore the rising intensity. Instead, let us start when the
laser pulse is 10% of its maximum value - the half-width-at-10%-maximum,
$HW0.1M$. For a Gaussian beam, this is:&lt;/p>
&lt;p>$HW0.1M = \frac{FWHM}{2} \sqrt{\frac{\ln(10)}{\ln(2)}}$&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:control
nx = 700
ny = 400
t_end = 100e-15
x_min = 0
x_max = 35e-6
y_min = -10e-6
y_max = 10e-6
stdout_frequency = 100
end:control
begin:boundaries
bc_x_min = simple_laser
bc_x_max = open
bc_y_min = open
bc_y_max = open
end:boundaries
begin:constant
t_fwhm = 40.0e-15
y_fwhm = 5.0e-6
sigma_t = t_fwhm / sqrt(2*loge(2))
sigma_y = y_fwhm / sqrt(2*loge(2))
t_hw01m = 0.5 * t_fwhm * sqrt(loge(10)/loge(2))
end:constant
begin:laser
boundary = x_min
intensity_w_cm2 = 1.0e18
lambda = 1.0e-6
profile = gauss(y,0,sigma_y)
t_profile = gauss(time,t_hw01m,sigma_t)
end:laser
begin:output
dt_snapshot = 10 * femto
poynt_flux = always
end:output
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="laser_pulse.png" alt="Uniform laser">&lt;/p>
&lt;p>Here we see that the laser FWHM in $x$ and $y$ are 12 $\mu m$ and 5 $\mu m$
respectively, where the $x$ FWHM corresponds to a temporal FWHM of 40 fs, as
expected. Also, because there is little contact between the pulse and the
boundaries, we do not have any numerical boundary disturbance.&lt;/p>
&lt;h2 id="focussing_a_gaussian_beam">Focussing a Gaussian Beam&lt;/h2>
&lt;p>A laser can be driven on the boundary so that it focusses on a given
spot. Basic details of how to do this are
&lt;a href="https://en.wikipedia.org/wiki/Gaussian_beam" target="_blank" rel="noopener">here&lt;/a>. To summarise, using
the paraxial approximation, the electric fields for a $x$-propagating,
$y$-polarised Gaussian beam take the form:&lt;/p>
&lt;p>$\pmb{E}(r,x) = E_0 \frac{w_0}{w(x)} e^{-r^2/w(x)^2} e^{-i(kx + k\frac{r^2}{2R_c(x)}-\psi(x))} \hat{\pmb{y}}$&lt;/p>
&lt;p>where&lt;/p>
&lt;ul>
&lt;li>$r$ is the radial distance from the laser propagation axis&lt;/li>
&lt;li>$x$ is axial distance along the wave, with $x=0$ at the focus&lt;/li>
&lt;li>$E_0$ is the peak electric field amplitude at the focus&lt;/li>
&lt;li>$w(x)$ is the beam-waist at $x$ (radial distance where field strength drops by $e^{-1}$)&lt;/li>
&lt;li>$w_0$ is $w(x=0)$&lt;/li>
&lt;li>$k$ is the laser wave-vector&lt;/li>
&lt;li>$R_c(x)$ is the radius of curvature at $x$&lt;/li>
&lt;li>$\psi(x)$ is the Gouy phase correction&lt;/li>
&lt;/ul>
&lt;p>If the fields on the simulation boundary are of this form,
then the fields will propagate according to this equation, and
a focal spot will be formed. Note that this propagation is only expected
provided the paraxial approximation is satisfied. This implies that, for vacuum propagation, the laser
wavelength, $\lambda$ is much smaller than the beam-waist: $\lambda &amp;laquo; w_0$.&lt;/p>
&lt;p>The following deck
gives an example for a laser attached to x_min. Two constant blocks are provided:
the first gives the user control over the focused laser properties, and the
second derives variables to be used in the laser block. The user only needs to
touch the first, which sets the intensity full-width-at-half-maximum (related to
beam-waist), the peak, cycle-averaged intensity, the laser wave-length and the
distance from the $x_{min}$ boundary to the focal point.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:control
nx = 2400
ny = 1200
t_end = 100e-15
x_min = 0
x_max = 20e-6
y_min = -5e-6
y_max = 5e-6
stdout_frequency = 100
end:control
begin:boundaries
bc_x_min = simple_laser
bc_x_max = open
bc_y_min = open
bc_y_max = open
end:boundaries
begin:constant
I_fwhm = 2.0e-6 # FWHM of laser intensity
I_peak_Wcm2 = 1.0e15 # 0.5 * eps0 * c * E_peak^2
las_lambda = 1.0e-6 # Laser wavelength
foc_dist = 5.0e-6 # Boundary to focal point distance
end:constant
begin:constant
las_k = 2.0 * pi / las_lambda
w0 = I_fwhm / sqrt(2.0 * loge(2.0)) # Beam Waist
ray_rang = pi * w0^2 / las_lambda # Rayleigh range
w_boundary = w0 * sqrt(1.0 + (foc_dist/ray_rang)^2) # Waist on boundary
I_boundary = I_peak_Wcm2 * (w0 / w_boundary)^2 # Intens. on boundary
rad_curve = foc_dist * (1.0 + (ray_rang/foc_dist)^2) # Boundary curv. rad.
gouy = atan(-foc_dist/rad_curve) # Boundary Gouy shift
end:constant
begin:laser
boundary = x_min
intensity_w_cm2 = I_boundary
lambda = las_lambda
phase = las_k * y^2 / (2.0 * rad_curve) - gouy
profile = gauss(y, 0, w_boundary)
end:laser
begin:output
name = o1
dt_snapshot = 10 * femto
poynt_flux = always
end:output
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="FocussedBeam.png" alt="The focussed beam">&lt;/p>
&lt;p>In this example, EPOCH correctly reproduces the focal point position,
laser wavelength, and radial FWHM at the focus - however, the peak
intensity is only $0.88\times 10^{15} \text{ Wcm}^{-2}$. This
intensity reduction from target is due to the tight focal spot,
with $w_0\approx 1.7$ μm being close to $\lambda = 1.0$ μm.&lt;/p>
&lt;p>The deck is based on the laser test deck supplied with EPOCH, with a
modified laser and longer runtime. Other classes of beam (Bessel etc)
can be created similarly.&lt;/p>
&lt;h2 id="angle_laser_injection">Injecting the laser at an angle&lt;/h2>
&lt;p>By setting up a phase shift as a function of space, it is possible to force
wavefronts to arrive at different points on the boundary at different times
(for 2D and 3D simulations). This allows the user to inject lasers with an
angle to the boundary normal. Note that the laser boundary theory expects lasers
to be injected perpendicular to the boundary, so it will almost always be better
to obtain oblique incidence by rotating the target in EPOCH. Angular injection
makes the most sense when multiple lasers are present with difference incident
angles.&lt;/p>
&lt;h4 id="laser_angled">Angled incident laser profile&lt;/h4>
&lt;p>&lt;img src="oblique_incidence.png" alt="Angled laser profile in EPOCH2D">&lt;/p>
&lt;p>The setup for this is not entirely straightforward and requires a little
bit of explanation. The above
&lt;a href="#laser_angled">figure&lt;/a> illustrates a laser being driven at
an angle on the $x_{min}$ boundary. Different wave fronts cross the $y$-axis
at different places and this forms a sinusoidal profile along $y$ that
represents the phase. The wavelength of this profile is
given by $\lambda_\phi = \lambda / \sin\theta$, where $\lambda$ is the
wavelength of the laser and $\theta$ is the angle of the propagation
direction with respect to the $x$-axis. The actual phase to use will
be $\phi(y) = -k_\phi y = -2\pi y / \lambda_\phi$. It is negative because
the phase of the wave is propagating in the positive $y$ direction.
It is also necessary to alter the wavelength of the driver since this
is given in the direction perpendicular to the boundary. The new
wavelength to use will be $\lambda\cos\theta$. The
&lt;a href="#laser_angled">figure&lt;/a> shows
the resulting $E_y$ field for a laser driven at an angle of $\pi / 6$. Note
that since the boundary conditions in the code are derived for propagation
perpendicular to the boundary, there will be artefacts on the scale of the
grid for lasers driven at an angle.&lt;/p>
&lt;p>The input deck used to generate this figure is given below:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:control
nx = 2000
ny = 2000
t_end = 50.e-15
x_min = -10.0e-6
x_max = 10.0e-6
y_min = -10.0e-6
y_max = 10.0e-6
end:control
begin:boundaries
bc_x_min = simple_laser
bc_x_max = simple_outflow
bc_y_min = simple_outflow
bc_y_max = simple_outflow
end:boundaries
begin:constant
laser_angle = pi / 6 # Set angle of laser w.r.t positive x unit vector
laser_fwhm = 2.0e-6 # Size of gaussian profile for laser electric field
laser_wavelength = 1.0e-6
laser_k = 2 * pi / laser_wavelength
end:constant
begin:laser
boundary = x_min
intensity_w_cm2 = 1.0e15
profile = gauss(y, 0, laser_fwhm / (2.0 * sqrt(loge(2.0))))
t_profile = 1
phase = -y * laser_k * sin(laser_angle) # Vary wave-front position in space
lambda = laser_wavelength * cos(laser_angle) # Space wave-fronts apart
# correctly along k
end:laser
begin:output
dt_snapshot = 10.e-15
grid = always
ey = always
end:output
&lt;/code>&lt;/pre></description></item><item><title>Restart from SDF dump</title><link>/quickstart/basic_examples/restart_example.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/quickstart/basic_examples/restart_example.html</guid><description>&lt;p>It can sometimes be useful to restart an &lt;strong>EPOCH&lt;/strong> simulation from an SDF file.
Supercomputers may often place limits on job length, or systems may be prone to
crashing, so code-restarts can help prevent CPU waste.&lt;/p>
&lt;p>Using the &lt;strong>EPOCH&lt;/strong>
&lt;a href="/documentation/input_deck/input_deck_output_block.html">output block&lt;/a>,
the user is able to force the code to write restart-dumps. These differ from
regular dumps, as they write all the particle and field properties required to
restart the simulation. These will quite often be large and slow files to write,
so there is a trade-off between simulation speed (no restarts) and safety (many
restart dumps).&lt;/p>
&lt;p>In this page we will simulate a basic laser injected into a vacuum, and run the
simulation with and without restarts.&lt;/p>
&lt;h2 id="no_restart">Simulation set-up&lt;/h2>
&lt;p>Here we provide the input deck for a basic 2D simulation where a plane wave
enters
the simulation window through the &lt;code>x_min&lt;/code> boundary. This creates an SDF file
containing the &lt;code>Ey&lt;/code> field every 10 fs. This is a lightweight diagnostic, and
is not sufficient to restart the whole simulation. A plot of the electric field
from the &lt;code>0010.sdf&lt;/code> file is also present, along with the MATLAB script which
created it (other post-processing tools are available). Instructions on running
EPOCH input decks are provided
&lt;a href="/quickstart.html">here&lt;/a>.&lt;/p>
&lt;pre>&lt;code>begin:control
nx = 500
ny = 500
t_end = 100 * femto
x_min = 0.0
x_max = 10.0e-6
y_min = -5.0e-6
y_max = 5.0e-6
stdout_frequency = 10
end:control
begin:boundaries
bc_x_min = simple_laser
bc_x_max = open
bc_y_min = periodic
bc_y_max = periodic
end:boundaries
begin:laser
boundary = x_min
intensity_w_cm2 = 1.0e15
lambda = 1.0e-6
profile = 1.0
t_profile = 1.0
end:laser
begin:output
dt_snapshot = 10.0e-15
ey = always
end:output
&lt;/code>&lt;/pre>
&lt;p>This code took 3 seconds to run on a 4 core laptop. For the MATLAB
post-processing, the contents of &lt;code>epoch/SDF/MATLAB&lt;/code> were copied into the
directory containing the SDF files and &lt;code>input.deck&lt;/code>, and a plot was generated
using this script:&lt;/p>
&lt;pre>&lt;code class="language-MatLab">% Extract data
data = GetDataSDF('0010.sdf');
% Format grid
x_edges = data.Electric_Field.Ey.grid.x;
y_edges = data.Electric_Field.Ey.grid.y;
x_centres = 0.5*(x_edges(2:end) + x_edges(1:end-1));
y_centres = 0.5*(y_edges(2:end) + y_edges(1:end-1));
[x_plot, y_plot] = meshgrid(x_centres, y_centres);
% Create and format plot
surf(x_plot*1.0e6, y_plot*1.0e6, data.Electric_Field.Ey.data','EdgeColor','none');
view(2);
xlabel('x [\mum]');
ylabel('y [\mum]');
cbar = colorbar;
cbar.Label.String = 'Ey [V/m]';
ax = gca;
ax.FontSize = 16;
title(sprintf('%g fs',data.time*1.0e15));
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="restart_example.png" alt="Ey field in basic example">&lt;/p>
&lt;h2 id="restarting-from-simulation-end">Restarting from simulation end&lt;/h2>
&lt;p>Now we have a basic script, let us run it in two simulations loading the second
from a restart-dump. In our first run, we will reduce the run-time to 50 fs, and
force the final dump to be restartable. We will start the second simulation from
the 50 fs restart-dump, and run to completion.&lt;/p>
&lt;p>For the first run, take the previous &lt;code>input.deck&lt;/code> and make some changes.
Firstly, change &lt;code>t_end&lt;/code> in the control block from &lt;code>100 * femto&lt;/code> to &lt;code>50 * femto&lt;/code>.
Next, add the following line to the output block:&lt;/p>
&lt;pre>&lt;code>force_final_to_be_restartable = T
&lt;/code>&lt;/pre>
&lt;p>When we run this simulation, we find that we generate output files from
&lt;code>0000.sdf&lt;/code> to &lt;code>0005.sdf&lt;/code>. If we inspect the file-sizes, we&amp;rsquo;ll see that
&lt;code>0005.sdf&lt;/code> has a size of 18 MB, while the rest have 2 MB - our restart-dump file
is much larger.&lt;/p>
&lt;p>For the restarted run, change &lt;code>t_end&lt;/code> in the control block back to
&lt;code>100 * femto&lt;/code>, and add the control block line:&lt;/p>
&lt;pre>&lt;code>restart_snapshot = 5
&lt;/code>&lt;/pre>
&lt;p>When running the restarted deck, &lt;strong>EPOCH&lt;/strong> will print the lines:&lt;/p>
&lt;pre>&lt;code> Loading snapshot for time 5.0012906556442301E-014
Input file contains 29 blocks
Load from restart dump OK
&lt;/code>&lt;/pre>
&lt;p>if run successfully. You&amp;rsquo;ll see the SDF files continue from where they left off,
and if we were to once again print the &lt;code>Ey&lt;/code> field at &lt;code>0010.sdf&lt;/code>, we once again
find what we had before:&lt;/p>
&lt;p>&lt;img src="restart_example.png" alt="Ey field in basic example">&lt;/p>
&lt;h2 id="restart-checkpoints">Restart checkpoints&lt;/h2>
&lt;p>The previous example assumed you could split your simulation up into obvious
chunks, but what if the nodes you run on have a tendency to crash? In this case,
it would make more sense to make multiple restart dumps. While this could be
achieved by replacing &lt;code>force_final_to_be_restartable&lt;/code> with &lt;code>restart_dump_every&lt;/code>
to make multiple restart dumps, you may want to separate your restart dumps from
your usual dumps. This can be done using multiple output blocks.&lt;/p>
&lt;p>The previous example has been extended to produce two sets out output files, one
labelled &lt;code>normal0000.sdf&lt;/code> to &lt;code>normal0010.sdf&lt;/code>, and the other labelled
&lt;code>restart0000.sdf&lt;/code> to &lt;code>restart0005.sdf&lt;/code>.&lt;/p>
&lt;pre>&lt;code>begin:control
nx = 500
ny = 500
t_end = 100 * femto
x_min = 0.0
x_max = 10.0e-6
y_min = -5.0e-6
y_max = 5.0e-6
stdout_frequency = 10
end:control
begin:boundaries
bc_x_min = simple_laser
bc_x_max = open
bc_y_min = periodic
bc_y_max = periodic
end:boundaries
begin:laser
boundary = x_min
intensity_w_cm2 = 1.0e15
lambda = 1.0e-6
profile = 1.0
t_profile = 1.0
end:laser
begin:output
name = normal
file_prefix = normal
dt_snapshot = 10.0e-15
ey = always
end:output
begin:output
name = restart
file_prefix = restart
restartable = T
dt_snapshot = 20.0e-15
end:output
&lt;/code>&lt;/pre>
&lt;p>As before, the &lt;code>normal&lt;/code> dumps only contain the &lt;code>Ey&lt;/code> data. However, because the
output block named &lt;code>restart&lt;/code> contains the &lt;code>restartable=T&lt;/code> flag, all these dumps
will be restart dumps. Once we have this, we can restart from any of the restart
SDF files. Because
these files now have a prefix, we must add a line like:&lt;/p>
&lt;pre>&lt;code>restart_snapshot = restart0004.sdf
&lt;/code>&lt;/pre>
&lt;p>to the control block, where we use the full file-name.&lt;/p>
&lt;h2 id="restart-at-end-of-the-cluster-job-allocation">Restart at end of the cluster job allocation&lt;/h2>
&lt;p>The issue with regular checkpoints is that it may be overkill for your job, and
any CPU time spent after the final checkpoint is wasted when you come to
restart. Also, writing a restart dump at the end of a simulation is less useful
when you run on supercomputers, as you don&amp;rsquo;t know where you&amp;rsquo;ll be at the end of
your maximum job time!&lt;/p>
&lt;p>In this case, you need a way to automatically stop the simulation as you near
the end of your allotted time, and &lt;em>then&lt;/em> write a restart dump so you can
continue later. This can be achieved using the &lt;code>STOP&lt;/code> file.&lt;/p>
&lt;p>While running, &lt;strong>EPOCH&lt;/strong> continuously scans the directory containing
&lt;code>input.deck&lt;/code> for a file with a filename &lt;code>STOP&lt;/code>. When this file appears,
&lt;strong>EPOCH&lt;/strong> completes the current time-step, writes a restart dump, ends the
simulation, and deletes the &lt;code>STOP&lt;/code> file. No lines need to be added to the
&lt;code>input.deck&lt;/code> in order to use the &lt;code>STOP&lt;/code> functionality.&lt;/p>
&lt;p>For example, if you were to submit an &lt;strong>EPOCH&lt;/strong> job on a super-computer with an
allocated time of 5 hours, and you wanted the code to stop at 4 hours 30 mins
(leaving you 30 minutes to write a restart dump), you could add the line:&lt;/p>
&lt;pre>&lt;code>(sleep 16200; touch STOP) &amp;amp;
&lt;/code>&lt;/pre>
&lt;p>to your job-script just before &lt;strong>EPOCH&lt;/strong> is run. This will create a background
process which will wait 16200 seconds, then create the &lt;code>STOP&lt;/code> file in the
working directory of the original command. If this is the same directory as your
input deck,
this will stop the code with (hopefully) enough time to write the restart dump.
You may want to check in advance how long a restart dump takes to write for your
project, to get the timing of the &lt;code>STOP&lt;/code> file appearence correct.&lt;/p></description></item></channel></rss>