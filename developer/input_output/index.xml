<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Input Output | EPOCH</title><link>/developer/input_output.html</link><atom:link href="/developer/input_output/index.xml" rel="self" type="application/rss+xml"/><description>Input Output</description><generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><image><url>/images/logo_hub4b4d6a0f57638acebb5550a80c8c030_9243_300x300_fit_lanczos_2.png</url><title>Input Output</title><link>/developer/input_output.html</link></image><item><title>Adding Outputs</title><link>/developer/input_output/adding_outputs.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/developer/input_output/adding_outputs.html</guid><description>&lt;h2 id="adding-a-derived-variable">Adding a derived variable&lt;/h2>
&lt;p>Derived variables are variables which are defined on the
Cartesian spatial grid but are not directly updated by the solver. They are
calculated when needed for output or for use in other physics packages. The
final form of a derived variable is an array on each processor with the same
size as the field arrays. Examples include &lt;code>number_density&lt;/code>, &lt;code>ekbar&lt;/code> and
&lt;code>poynting_flux&lt;/code>.&lt;/p>
&lt;p>A derived variable is defined on the same grid as the main simulation variables
and must be written to disk in such a way as to stitch the parts of the grid
from each processor together. This is achieved using the routine:&lt;/p>
&lt;pre>&lt;code class="language-perl">CALL sdf_write_plain_variable(sdf_handle, id, name, units, dims, stagger, &amp;amp;
grid_id, variable, subtype_field, subarray_field)
&lt;/code>&lt;/pre>
&lt;p>The parameters have the following types and meanings:&lt;/p>
&lt;ul>
&lt;li>block_id - The id name of the variable. This character string is a
unique identifier for
the variable in the file enabling a program to retrieve it later. Once
defined it should not change so that newer versions of EPOCH can still
identify variables generated by older versions.&lt;/li>
&lt;li>name - The display name of the variable. This character string is
the name that is used
by external programs to display an identifying name for the variable. If it
contains &amp;lsquo;/&amp;rsquo; characters then these are used by VisIt to group the variables.&lt;/li>
&lt;li>units - The units of the variable. This character string is used when
displaying the data units. For most variables in EPOCH these
are SI units.&lt;/li>
&lt;li>dims - An nD integer array containing the GLOBAL length of the variable
across all processors. In EPOCH a variable actually called &amp;ldquo;dims&amp;rdquo; exists
for variables which are the same size as the default field variables.&lt;/li>
&lt;li>stagger - An integer constant containing the stagger of a variable from
the cell centre of a cell. This property lets external programs know the
position of a variable on the grid.&lt;/li>
&lt;li>grid_id - The id name of the grid to which the variable is attached. In
EPOCH, the main grid is just called &amp;ldquo;grid&amp;rdquo;. Note that this property is
case sensitive.&lt;/li>
&lt;li>variable - The actual variable to be written to disk.&lt;/li>
&lt;li>subtype_field - This is an MPI type representing the layout of the data
across the processors. For a standard field variable, there is an
automatically created type called &amp;ldquo;subtype_field&amp;rdquo; which should be used
here.&lt;/li>
&lt;li>subarray_field - This is an MPI type representing the section of
the &amp;ldquo;variable&amp;rdquo; parameter to be written. For a standard field variable,
there is an automatically created type called &amp;ldquo;subarray_field&amp;rdquo; which
should be used here.&lt;/li>
&lt;/ul>
&lt;p>It&amp;rsquo;s probably easiest to read the diagnostics.F90 file and see how the code
implements the output of simple variables like ex or ey for an example of how
this works. Once the appropriate sdf_write call has
been added to the code, there is no further work
to be done. The IDL, MatLab and VisIt routines will all read the existence of
the variable from the metadata in the SDF file, and it will now be available to
view in all SDF reading packages.&lt;/p>
&lt;p>There is a working variable called &lt;code>array&lt;/code> which is large enough to
store a derived variable. It is
therefore recommended that to calculate derived variables a new subroutine
should be created which populates &lt;code>array&lt;/code> with the required variable
and then writes it to disk. An example would look like:&lt;/p>
&lt;pre>&lt;code class="language-perl">IF (IAND(dumpmask(c_dump_myvar), code)) THEN
CALL calc_my_variable(array)
CALL sdf_write_plain_variable(sdf_handle, 'my_var', 'Mine/variable', 'unit',
dims, c_stagger_cell_centre, 'grid', array, subtype_field, subarray_field)
ENDIF
&lt;/code>&lt;/pre>
&lt;p>where &lt;code>calc_my_variable&lt;/code> is a function which calculates the
variable which you wish to write. The form of this function depends on the type
of variable to be calculated and is given in the next section.&lt;/p>
&lt;h2 id="adding-a-particle-variable">Adding a particle variable&lt;/h2>
&lt;p>The next simplest type of output to add is a new property for all particles. To
add new particle variables to the output dump, two things are needed: a call
to the SDF command to write the data and an iterator function to iterate
through all the particles. &lt;strong>NOTE&lt;/strong>: This section only deals with new outputs
for &lt;em>existing&lt;/em> particle variables. Creation of a new particle variable is more
involved, and
requires modifying MPI routines.&lt;/p>
&lt;p>The iterators are stored in the file
&lt;code>iterators.F90&lt;/code>. An example iterator is:&lt;/p>
&lt;pre>&lt;code class="language-perl"> ! iterator for particle momenta
FUNCTION iterate_px(array, n_points, start)
REAL(num) :: iterate_px
REAL(num), DIMENSION(:), INTENT(OUT) :: array
INTEGER, INTENT(INOUT) :: n_points
LOGICAL, INTENT(IN) :: start
TYPE(particle), POINTER, SAVE :: cur
TYPE(particle_list), POINTER, SAVE :: current_list
INTEGER :: part_count
IF (start) THEN
CALL start_particle_list(current_species, current_list, cur)
ENDIF
part_count = 0
DO WHILE (ASSOCIATED(current_list) .AND. (part_count .LT. n_points))
DO WHILE (ASSOCIATED(cur) .AND. (part_count .LT. n_points))
part_count = part_count + 1
array(part_count) = cur%part_p(1)
cur=&amp;gt;cur%next
ENDDO
! If the current partlist is exhausted, switch to the next one
IF (.NOT. ASSOCIATED(cur)) CALL advance_particle_list(current_list, cur)
ENDDO
n_points = part_count
iterate_px = 0
END FUNCTION iterate_px
&lt;/code>&lt;/pre>
&lt;p>This is a fairly complicated routine which includes code for dealing with the
possibility of particle species not being dumped, and other complicated
book keeping. Luckily, there is only one line in the routine which needs to
change to output a new variable. This being:&lt;/p>
&lt;pre>&lt;code class="language-perl"> array(part_count) = cur%part_p(1)
&lt;/code>&lt;/pre>
&lt;p>To write a new iterator, you just have to copy the skeleton of an existing
iterator and change this line to copy your particle property into the &amp;ldquo;array&amp;rdquo;
array. The details of the particle structure&amp;rsquo;s contents is explained
&lt;a href="/developer/core_structure/macro_particles.html">here&lt;/a>.
Once your new iterator has been written and added into
the &lt;code>iterators.F90&lt;/code> file, it&amp;rsquo;s time to add the SDF routine to actually
write the data. The routine is:&lt;/p>
&lt;pre>&lt;code class="language-perl"> CALL write_particle_variable(c_dump_id, code, name, iterator)
&lt;/code>&lt;/pre>
&lt;p>The parameters this time are&lt;/p>
&lt;ul>
&lt;li>c_dump_id - The index into the dumpmask for this variable.&lt;/li>
&lt;li>code - The dump code for the current output dump.&lt;/li>
&lt;li>name - The display name to use for this variable.&lt;/li>
&lt;li>iterator - The name of the iterator function that you created in
the previous step. Note that this is not a string but simply the name of the
function.&lt;/li>
&lt;/ul>
&lt;p>Once again, looking at how this is implemented for one of the existing
variables (e.g. px) is probably the most enlightening way to see how it
works. As for the fluid variables, the new variable will appear in IDL, MatLab
and VisIt.&lt;/p>
&lt;p>At this point it is possible to write any property which is similar to the
default field variables or the default particle properties. It becomes slightly
more challenging if you want to write other types of variable into an output
file.&lt;/p></description></item><item><title>Basic Output</title><link>/developer/input_output/basic_output.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/developer/input_output/basic_output.html</guid><description>&lt;p>EPOCH uses a file format called &lt;em>SDF&lt;/em> which was custom developed for use
with codes developed by CFSA at the University of Warwick. However, it isn&amp;rsquo;t necessary
to have a full understanding of the file format
to add the output of new variables to EPOCH. To add a new variable to
EPOCH&amp;rsquo;s output, you simply have to use the supplied subroutines of the SDF
library which is part of EPOCH. The file output from EPOCH takes place in
&lt;em>diagnostics.F90&lt;/em>, so to add new variables to the output you must
add additional code there. Looking through the listings, you will see two lines:&lt;/p>
&lt;pre>&lt;code class="language-perl"> CALL sdf_open(sdf_handle, filename, rank, comm, c_sdf_write)
CALL sdf_close(sdf_handle)
&lt;/code>&lt;/pre>
&lt;p>These, as may be expected, are the commands which open and close the SDF file.
It is perfectly possible to create new SDF files containing only your own data.
There are various commands in-between which actually write the data into the
file. These commands start with &lt;code>sdf_&lt;/code> to ensure that the don&amp;rsquo;t
conflict with any other subroutine names in the code.
Some more complex areas of I/O, such as the particle probes
and the distribution function routines call other subroutines in their
respective source files, but these too make use of the SDF routines to actually
write data. A user should never try to write data directly to the output file,
since this will cause problems with internal parts of the SDF format and
generate a nonsensical file.&lt;/p>
&lt;h2 id="the-dumpmask">The dumpmask&lt;/h2>
&lt;p>Looking through &lt;code>diagnostics.F90&lt;/code> there are many lines with commands which
begin &lt;code>sdf_&lt;/code>, but are all prepended with a command which looks
like:&lt;/p>
&lt;pre>&lt;code class="language-perl"> IF (IAND(dumpmask(c_dump_id), code) .NE. 0) THEN
&lt;/code>&lt;/pre>
&lt;p>This is the method by which EPOCH allows the end user to specify whether a
variable should be dumped, and whether it should only be dumped at
full/partial/restart dumps. &lt;strong>dumpmask&lt;/strong> is an integer array, the length of
which is defined by the variable &lt;code>num_vars_to_dump&lt;/code> in
&lt;code>shared_data.F90&lt;/code> and contains the bitmask representing all the
types of output which should be written for the associated variable. The
possible values in the bitmask are:&lt;/p>
&lt;ul>
&lt;li>&lt;code>c_io_never&lt;/code> - Never dump this variable.&lt;/li>
&lt;li>&lt;code>c_io_always&lt;/code> - Dump this variable at every output dump.&lt;/li>
&lt;li>&lt;code>c_io_full&lt;/code> - Dump this variable at full dumps.&lt;/li>
&lt;li>&lt;code>c_io_restartable&lt;/code> - Dump this variable for restart dumps.&lt;/li>
&lt;li>&lt;code>c_io_species&lt;/code> - If meaningful for this variable, write
information for each species rather than integrated over all species.&lt;/li>
&lt;li>&lt;code>c_io_no_sum&lt;/code> - If meaningful for this variable, do not
write information integrated over all species.&lt;/li>
&lt;li>&lt;code>c_io_averaged&lt;/code> - If meaningful for this variable, write
this variable averaged over time.&lt;/li>
&lt;li>&lt;code>c_io_snapshot&lt;/code> - If meaningful for this variable, write
the non-averaged value of the variable.&lt;/li>
&lt;/ul>
&lt;p>The &lt;code>c_dump_id&lt;/code> entry is a constant defined in
&lt;code>shared_data.F90&lt;/code> which identifies the variable&amp;rsquo;s index within
this dumpmask.&lt;/p>
&lt;p>When adding a new variable to be written to disk, the value of
&lt;code>num_vars_to_dump&lt;/code> should be increased to match the number of new
written variables. Next, open the file &lt;code>src/deck/deck_io_block.F90&lt;/code>
and find the line:&lt;/p>
&lt;pre>&lt;code class="language-perl"> CHARACTER(LEN=entry_length), DIMENSION(io_block_elements) :: &amp;amp;
io_block_name = ...
&lt;/code>&lt;/pre>
&lt;p>Simply add new strings for your new variables to the end of the
definitions along with its &lt;code>c_dump_id&lt;/code> value. These new variable
names should then be placed in your input decks
in the same place as the existing I/O information and take the same parameters.&lt;/p>
&lt;h2 id="precompiler-directives-and-the-input-deck">Precompiler directives and the input deck&lt;/h2>
&lt;p>In theory, it is possible for someone to request a feature of the code in the
input deck which this version hasn&amp;rsquo;t been compiled with. In this
case, there is a special error code &lt;code>c_err_pp_options_wrong&lt;/code>
which causes the input deck parser to give a meaningful error. You should also
set the string &lt;code>extended_error_string&lt;/code> to be the define
command for the missing preprocessor directive i.e
&lt;code>extended_error_string = &amp;quot;-DMY_PRECOMPILER_DIRECTIVE&amp;quot;&lt;/code>&lt;/p></description></item><item><title>Custom Deck</title><link>/developer/input_output/custom_deck.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/developer/input_output/custom_deck.html</guid><description>&lt;p>For some types of changes to the code it is more convenient to have the end
user pass new parameters into the code. This can be for several reasons, and
the section on permanent additions to the input deck is given in extensions. At
this stage, we will describe how to temporarily add new
elements to the input deck parser routines, allowing parameterising of
internal and manual initial conditions.&lt;/p>
&lt;p>Custom input deck elements are setup in the file
&lt;code>src/user_interaction/custom_deck.f90&lt;/code>. The function
&lt;code>custom_blocks_handle_element&lt;/code> is called when a new block is
started which the core parser is not familiar with, and once for each element
of a block. The function &lt;code>custom_blocks_check&lt;/code> is called once the
entire deck has been parsed and is used to check that all the elements which
are required for the code to run have been specified.&lt;/p>
&lt;h2 id="custom_blocks_handle_element">custom_blocks_handle_element&lt;/h2>
&lt;p>There are three parameters passed to
&lt;code>custom_blocks_handle_element&lt;/code>, which are:&lt;/p>
&lt;ul>
&lt;li>block_name - The name of the block specified in the
&lt;code>begin:blockname&lt;/code> part of the input deck.&lt;/li>
&lt;li>element - The name of the element in an input deck
&lt;code>element = value&lt;/code> pair.&lt;/li>
&lt;li>value - The string representation of the value in an input deck
&lt;code>element = value&lt;/code> pair.&lt;/li>
&lt;/ul>
&lt;p>&lt;code>custom_blocks_handle_element&lt;/code> is first called when a new block
is begun
using &lt;code>begin:blockname&lt;/code> and &amp;ldquo;blockname&amp;rdquo; is not recognised by the
core input deck parser. The first thing that it does is test whether or not it
is a valid custom block. The code does this by passing in the blockname with
&lt;code>element&lt;/code> and &lt;code>value&lt;/code> set to the special constant called
&amp;ldquo;blank&amp;rdquo;. When extending the input deck, an end user should check if either
&lt;code>element&lt;/code> or &lt;code>value&lt;/code> are set to the special constant
&amp;ldquo;blank&amp;rdquo;, and if they are then test to see whether the blockname is known or
not. If the blockname is known then the code should return the error code
&lt;code>c_err_none&lt;/code> (No error). If the blockname is not known then the
code should return &lt;code>c_err_unknown_block&lt;/code> and the deck parser will
just skip the block. In operation, this looks like:&lt;/p>
&lt;pre>&lt;code class="language-perl">FUNCTION custom_blocks_handle_element(block_name, element, value) &amp;amp;
RESULT(errcode)
CHARACTER(LEN=string_length), INTENT(IN) :: block_name, element, value
INTEGER :: errcode
IF (str_cmp(block_name, &amp;quot;custom&amp;quot;)) THEN
IF (element .EQ. blank .OR. value .EQ. blank) THEN
! If element or value are blank then just testing block so
! return c_err_none
errcode = c_err_none
RETURN
ENDIF
ENDIF
! The following line must always be present
errcode = c_err_unknown_block
END FUNCTION custom_blocks_handle_element
&lt;/code>&lt;/pre>
&lt;p>In order to simplify Fortran&amp;rsquo;s rather annoying string handling behaviour,
several helper functions have been defined and the most used one is
&lt;code>str_cmp(string1, string2)&lt;/code>. This is a simple routine which returns
true if string1 == string2 and false otherwise. It is case sensitive but can
deal with differing string lengths etc. The next stage is to deal with the
actual &lt;code>element = value&lt;/code> pairs in the deck. Each time that a new pair
is read from the deck, &lt;code>custom_blocks_handle_element&lt;/code> is called
with &lt;code>element&lt;/code> and &lt;code>value&lt;/code> having the values read from the
deck. To test for known elements they should just be checked against a known
list of names using &lt;code>str_cmp&lt;/code> and return the error code
&lt;code>c_err_unknown_element&lt;/code> if the element isn&amp;rsquo;t a known element. This
looks like:&lt;/p>
&lt;pre>&lt;code class="language-perl">FUNCTION custom_blocks_handle_element(block_name, element, value) &amp;amp;
RESULT(errcode)
CHARACTER(LEN=string_length), INTENT(IN) :: block_name, element, value
INTEGER :: errcode
IF (str_cmp(block_name, &amp;quot;custom&amp;quot;)) THEN
IF (element .EQ. blank .OR. value .EQ. blank) THEN
! If element or value are blank then just testing block so
! return c_err_none
errcode = c_err_none
RETURN
ENDIF
errcode = c_err_unknown_element
! Now test for the real elements
IF (str_cmp(element, &amp;quot;int_element&amp;quot;)) THEN
errcode = c_err_none
ENDIF
IF (str_cmp(element, &amp;quot;real_element&amp;quot;)) THEN
errcode = c_err_none
ENDIF
IF (str_cmp(element, &amp;quot;logical_element&amp;quot;)) THEN
errcode = c_err_none
ENDIF
RETURN
ENDIF
! The following line must always be present
errcode = c_err_unknown_block
END FUNCTION custom_blocks_handle_element
&lt;/code>&lt;/pre>
&lt;p>This version of the code will allow you to add a new block called &amp;ldquo;custom&amp;rdquo;
with elements
&amp;ldquo;int_element&amp;rdquo;, &amp;ldquo;real_element&amp;rdquo; and &amp;ldquo;logical_element&amp;rdquo; and the
code will parse them successfully, while any other block or any other element
in the block &amp;ldquo;custom&amp;rdquo; will throw errors. However, at this stage the code
doesn&amp;rsquo;t actually read any of the values from the deck. To make it useful, any
variable which is read from the input deck must be stored in a global
variable. Defining global variables are explained in more detail in the
relevant section of the manual, but in short, any variable defined in the
module &lt;code>shared_data&lt;/code> in the file &lt;code>src/shared_data.F90&lt;/code>
will be a global variable. After the variables have been setup, there are once
again helper functions to make converting the text from the deck into a normal
Fortran90 variable. These helper functions are:&lt;/p>
&lt;ul>
&lt;li>as_integer - Attempts to convert a string to an integer. Invokes the
maths parser.&lt;/li>
&lt;li>as_real - Attempts to convert a string to a REAL(num). Invokes the maths
parser.&lt;/li>
&lt;li>as_logical - Attempts to convert a string to a logical. Does not invoke
the maths parser (must be either &amp;ldquo;T&amp;rdquo; or &amp;ldquo;F&amp;rdquo;).&lt;/li>
&lt;/ul>
&lt;p>They are used pretty much as expected, except that the return value is passed
to the functions so that they can report errors while trying to parse the
string. An example would then be:&lt;/p>
&lt;pre>&lt;code class="language-perl">FUNCTION custom_blocks_handle_element(block_name, element, value) &amp;amp;
RESULT(errcode)
CHARACTER(LEN=string_length), INTENT(IN) :: block_name, element, value
INTEGER :: errcode, int_element
REAL(num) :: real_element
LOGICAL :: logical_element
IF (str_cmp(block_name, &amp;quot;custom&amp;quot;)) THEN
IF (element .EQ. blank .OR. value .EQ. blank) THEN
! If element or value are blank then just testing block so
! return c_err_none
errcode = c_err_none
RETURN
ENDIF
errcode = c_err_unknown_element
! Now test for the real elements
IF (str_cmp(element, &amp;quot;int_element&amp;quot;)) THEN
errcode = c_err_none
int_element = as_integer(value, errcode)
ENDIF
IF (str_cmp(element, &amp;quot;real_element&amp;quot;)) THEN
errcode = c_err_none
real_element = as_real(value, errcode)
ENDIF
IF (str_cmp(element, &amp;quot;logical_element&amp;quot;)) THEN
errcode = c_err_none
logical_element = as_logical(value, errcode)
ENDIF
RETURN
ENDIF
! The following line must always be present
errcode = c_err_unknown_block
END FUNCTION custom_blocks_handle_element
&lt;/code>&lt;/pre>
&lt;p>It is possible to perform more advanced types of evaluation of maths
expressions such as reading arrays etc. but this is beyond the scope of this
manual at present.&lt;/p>
&lt;h2 id="custom_blocks_check">custom_blocks_check&lt;/h2>
&lt;p>This function is called when all the blocks in the input deck have been
evaluated and is used to check that all required parameters have been set. If
all required elements have been set then you should just return
&lt;code>c_err_none&lt;/code>, otherwise return
&lt;code>c_err_missing_elements&lt;/code>. How you test that required elements have
been set is up to the developer, and for testing and personal use (which is
all that the custom deck parts of the code should be used for) it is
acceptable to just not check and always return &lt;code>c_err_none&lt;/code>. If
permanently expanding the deck, error trapping should always be written.&lt;/p></description></item><item><title>Custom Maths Parser</title><link>/developer/input_output/custom_maths_parser.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/developer/input_output/custom_maths_parser.html</guid><description>&lt;p>Sometimes the complexity in changing the input.deck file is due to the fact that
a function which must be used is fairly complex in form and is not supplied
with the core code. It must therefore be represented in the input deck maths
parser. This can be a significant cause of complexity for some problems, and
in this case, there are three options:&lt;/p>
&lt;ol>
&lt;li>Put up with it and implement in the deck&lt;/li>
&lt;li>Use the internal initial conditions rather than the deck&lt;/li>
&lt;li>Extend the maths parser to include your function&lt;/li>
&lt;/ol>
&lt;p>Extending the maths parser can either
be permanent (described in extensions) or temporary (described
here). All of the routines used in extending the maths parser are in the file
&lt;code>user_interaction/custom_parser.f90&lt;/code>. Temporarily adding elements to the parser
is much easier than a permanent addition. It is
possible to add new constants and functions to the maths parser. It is hoped
that in a future release of EPOCH this will be extended to allow custom
operators as well.&lt;/p>
&lt;p>As an example, lets look at adding a new function (lorentz) for a
Lorentzian distribution, and adding a new constant, phi.&lt;/p>
&lt;h2 id="registering-your-new-constantfunction">Registering your new constant/function&lt;/h2>
&lt;p>Before a new constant or function
can be defined it must be registered. In the registration phase the text
representation of the function or constant is given to the parser subroutines
and the user is returned an integer handle for the registered object. The
numerical handle must be stored so that that all of the functions in this
module can access it, so they should be placed after the &lt;code>IMPLICIT NONE&lt;/code> statement at the top of the file and defined as:&lt;/p>
&lt;pre>&lt;code class="language-perl">INTEGER :: c_func_lorentz
INTEGER :: c_const_phi
&lt;/code>&lt;/pre>
&lt;p>Note that the names given to the constants is obviously at the developers
discretion, but these names comply with the EPOCH style guide.
Actually registering the objects is done in the &lt;code>register_objects&lt;/code>
subroutine which should include lines to register functions and constants.
An example is given below.&lt;/p>
&lt;pre>&lt;code class="language-perl">SUBROUTINE register_objects
c_func_lorentz = register_function(&amp;quot;lorentz&amp;quot;)
c_const_phi = register_constant(&amp;quot;phi&amp;quot;)
END SUBROUTINE register_objects
&lt;/code>&lt;/pre>
&lt;p>Note that the input deck parser is case sensitive, so the strings which are
given to &lt;code>register_function&lt;/code> and &lt;code>register_constant&lt;/code>
should be in the case that they will appear in the input deck. To follow the
EPOCH style guide this should be all lowercase. At this point, the maths
parser would start to recognise the new function/constant, but would still
give error messages since they haven&amp;rsquo;t yet been implemented.&lt;/p>
&lt;h2 id="setting-up-new-constants">Setting up new constants&lt;/h2>
&lt;p>Once a new constant has been registered it must be described using the
&lt;code>custom_constant&lt;/code> function. In 2D this function looks like:&lt;/p>
&lt;pre>&lt;code class="language-perl">FUNCTION custom_constant(opcode, ix, iy, errcode)
INTEGER, INTENT(IN) :: opcode, ix, iy
INTEGER, INTENT(INOUT) :: errcode
REAL(num) :: custom_constant
! Leave these lines in place. They cause the code to throw an error if
! The opcode is unknown
custom_constant = 0.0_num
errcode = IOR(errcode, c_err_unknown_element)
END FUNCTION custom_constant
&lt;/code>&lt;/pre>
&lt;p>The parameters are&lt;/p>
&lt;ul>
&lt;li>&lt;code>opcode&lt;/code> - The operator code of the constant requested. This will be the
integer handle returned from &lt;code>register_constant&lt;/code>.&lt;/li>
&lt;li>&lt;code>ix&lt;/code>, &lt;code>iy&lt;/code>, &lt;code>iz&lt;/code> - Some constants are actually evaluated at specific points in
space and ix, iy, iz are the gridpoint number of the location currently being
evaluated. If you are specifying a simple constant then just ignore
these. If your constant does depend upon space then directly subscript your
array with ix, iy, iz as needed to read the correct location.&lt;/li>
&lt;li>&lt;code>errcode&lt;/code> - The error code which should be passed back to the
parser. If for some reason you cannot evaluate your constant then you should
&lt;code>IOR&lt;/code> errcode with the appropriate error code (all the error
codes are listed in appendix A). Note that errcode should never be SET to
any specific error code when extending the parser, since this might
overwrite errors put in place earlier in the parsing sequence. This is
different to extending the input deck where the error code is set.&lt;/li>
&lt;/ul>
&lt;p>The function should just return the evaluated value of the constant requested
by &lt;code>opcode&lt;/code>. This might look like:&lt;/p>
&lt;pre>&lt;code class="language-perl">FUNCTION custom_constant(opcode, ix, iy, errcode)
INTEGER, INTENT(IN) :: opcode, ix, iy
INTEGER, INTENT(INOUT) :: errcode
REAL(num) :: custom_constant
IF (opcode .EQ. c_const_phi) THEN
custom_constant = pi
RETURN
ENDIF
! Leave these lines in place. They cause the code to throw an error if
! The opcode is unknown
custom_constant = 0.0_num
errcode = IOR(errcode, c_err_unknown_element)
END FUNCTION custom_constant
&lt;/code>&lt;/pre>
&lt;p>Note that when &lt;code>opcode&lt;/code> is successfully recognised, the code sets
the return value and returns straight away. This is how all constants should
work, since the last line forces the function to return an error code. This
last line is in place to trap people registering constants but never defining
them. Without this line, it is possible to define a constant which is
never specified and have the code complete OK with a random value for that
constant.&lt;/p>
&lt;p>The constant &amp;ldquo;phi&amp;rdquo; should now work fine when used anywhere in the input deck
and will return a value of $\pi$.&lt;/p>
&lt;h2 id="setting-up-new-functions">Setting up new functions&lt;/h2>
&lt;p>Setting up the new function &lt;code>lorentz&lt;/code> is very similar to setting up
the new constant. The relevant function is &lt;code>custom_function&lt;/code> and
when empty looks like:&lt;/p>
&lt;pre>&lt;code class="language-perl">FUNCTION custom_function(opcode, ix, iy, errcode)
INTEGER, INTENT(IN) :: opcode, ix, iy
INTEGER, INTENT(INOUT) :: errcode
REAL(num) :: custom_function
REAL(num) :: values(5)
! Leave these lines in place. They cause the code to throw an error if
! The opcode is unknown
custom_function = 0.0_num
errcode = IOR(errcode, c_err_unknown_element)
END FUNCTION custom_function
&lt;/code>&lt;/pre>
&lt;p>The parameters are&lt;/p>
&lt;ul>
&lt;li>&lt;code>opcode&lt;/code> - The operator code of the constant requested. This will be the
integer handle returned from \inlinecode {register_function}.&lt;/li>
&lt;li>&lt;code>ix&lt;/code>, &lt;code>iy&lt;/code>, &lt;code>iz&lt;/code> - Some functions are evaluated differently at specific points
in space and ix, iy, iz are the gridpoint number of the location currently
being evaluated. If you are specifying a simple function then just
ignore these. If your function does depend upon space then directly
subscript your array with ix, iy, iz as needed to read the correct location.&lt;/li>
&lt;li>&lt;code>errcode&lt;/code> - The error code which should be passed back to the
parser. If for some reason you cannot evaluate your function then you should
&lt;code>IOR&lt;/code> errcode with the appropriate error code. Note that errcode
should never be SET to any specific error code, since this might overwrite
errors put in place earlier in the parsing sequence.&lt;/li>
&lt;/ul>
&lt;p>The function should return the value of your evaluated constant. The
parameters which are passed to the function can be retrieved by the function
&lt;code>get_values(n, values)&lt;/code>, where &lt;code>n&lt;/code> is the number of
parameters to be returned and &lt;code>values&lt;/code> is a &lt;code>REAL(num)&lt;/code>
array of length &lt;code>n&lt;/code> which will hold the returned values . In this
implementation of the Lorentzian function there are three parameters: The
dependent variable, the location parameter and the scale parameter. The code
to implement the function therefore looks like:&lt;/p>
&lt;pre>&lt;code class="language-perl">FUNCTION custom_function(opcode, ix, iy, errcode)
INTEGER, INTENT(IN) :: opcode, ix, iy
INTEGER, INTENT(INOUT) :: errcode
REAL(num) :: custom_function
REAL(num) :: values(5)
IF (opcode .EQ. c_func_lorentz) THEN
CALL get_values(3, values(1:3))
! values(1) - Dependent variable
! values(2) - location parameter
! values(3) - scale parameter
custom_function = values(3)**2/((values(1)-values(2))**2+values(3)**2)
RETURN
ENDIF
! Leave these lines in place. They cause the code to throw an error if
! The opcode is unknown
custom_function = 0.0_num
errcode = IOR(errcode, c_err_unknown_element)
END FUNCTION custom_function
&lt;/code>&lt;/pre>
&lt;p>This function is then available at any point in the input deck and if I return
to the previous example ic.deck file, it would be used as follows:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:constant
particle_density = 100.0 # Particle number density
profile_x = lorentz(x,0.0,1.0)
profile_y = lorentz(y,0.0,1.0)
end:constant
begin:species
name = s1
# multiply density by real particle density
density = particle_density * profile_x * profile_y
# Set the temperature to be zero
temp_x = 0.0
temp_y = temp_x(s1)
# Set the minimum density for this species
density_min = 0.3*particle_density
end:species
begin:species
name = s2
# Just copy the density for species s1
density = density(s1)
# Just copy the temperature from species s1
temp_x = temp_x(s1)
temp_y = temp_y(s1)
# Set the minimum density for this species
density_min = 0.3*particle_density
end:species
&lt;/code>&lt;/pre>
&lt;p>It is therefore clear that the new lorentz function is essentially the same as
the built in gauss function. Note that due to the way that the parser works,
the end user is not required to deal with parameters which are themselves
maths expressions. They have been fully evaluated by the time they are
returned by &lt;code>get_values&lt;/code>. Note that the parser is not guaranteed to
be bulletproof. If a user calls &lt;code>get_values&lt;/code> requesting more
parameters than have been passed to the function then it will scramble the
stack which is used by the parser and cause the code to fail. Note that
calling &lt;code>get_values(2, values)&lt;/code> is not the same as calling
&lt;code>get_values(1, values)&lt;/code> twice, in fact calling
&lt;code>get_values(1, values)&lt;/code> multiple times will return the parameters in
&lt;em>reverse&lt;/em> order. This is normal and is a feature of how the maths parser
operates. It is possible to use this property to write functions which have a
variable number of parameters, but this is not recommended.&lt;/p></description></item><item><title>Error Codes</title><link>/developer/input_output/error_codes.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/developer/input_output/error_codes.html</guid><description>&lt;p>The input deck and maths parser in EPOCH use various named error codes to
report on errors which occur during the evaluation of the input deck. These
codes are&lt;/p>
&lt;ul>
&lt;li>&lt;code>c_err_none&lt;/code> - No error. Set an error code to c_err_none to state that
no error has occurred.&lt;/li>
&lt;li>&lt;code>c_err_unknown_block&lt;/code> - In the input deck a block has been found which is
not known. This should be returned in
&lt;code>custom_blocks_handle_element&lt;/code> if it is passed any block that it has not been written to handle.&lt;/li>
&lt;li>&lt;code>c_err_unknown_element&lt;/code> - In the input deck an element of a valid block
has been found which is not known. This should be returned in
&lt;code>custom_blocks_handle_element&lt;/code> if an element is requested which is
unknown.&lt;/li>
&lt;li>&lt;code>c_err_preset_element&lt;/code> - An element of the input deck has already been
set and is being set again. Usually this is an indication of a malformed input
deck file, so &lt;code>custom_blocks_handle_element&lt;/code> should try to
identify such situations and return this error message if
subsequent attempts to set the variable are being ignored.&lt;/li>
&lt;li>&lt;code>c_err_preset_element_use_later&lt;/code> - An element of the input deck has
already been set and is being set again. Usually this is an indication of a
malformed input deck file, so &lt;code>custom_blocks_handle_element&lt;/code> should try to
identify such situations and return this error message if
the subsequent attempts to set the variable override previous ones.&lt;/li>
&lt;li>&lt;code>c_err_bad_value&lt;/code> - A value which is being evaluated for the right
hand side of an element assignment is in some way invalid. Internally to the
code this usually means that a string which must be interpreted as a maths
expression or numerical constant is in some way malformed. It is also
acceptable to return this error code when a value has been passed which is
invalid for some other reason (the value is outside an acceptable range, etc.)&lt;/li>
&lt;li>&lt;code>c_err_missing_elements&lt;/code> - This is an error code returned when the
code is testing to make sure that all necessary elements of an input deck
file have been specified. It should be returned when some required parameter
is missing in the subroutine &lt;code>custom_blocks_check&lt;/code>.&lt;/li>
&lt;li>&lt;code>c_err_terminate&lt;/code> - This error code means that the code is in a state
where execution is impossible and the code must terminate once the input deck
has been read. Some other error codes automatically set c_err_terminate,
but it can always be IOR&amp;rsquo;ed with any error code to force the code to exit.
Note that just returning c_err_terminate will cause the code to
silently quit.&lt;/li>
&lt;li>&lt;code>c_err_required_element_not_set&lt;/code> - This means that the code
cannot parse an input deck element since another element which must be known
beforehand has not been set. This is intended for things like setting the
species information where the number of species must be known in
advance. This error code uses the extended error string to give user friendly
feedback. If you return this error code then you should set
extended_error_string to be equal to the name of the required element which
has not been set. If multiple previous elements are required then the code
should be set up so that it checks for the presence of the required elements
in order and reports on missing elements so that the end user can fix them
one by one.&lt;/li>
&lt;li>&lt;code>c_err_pp_options_wrong&lt;/code> - If you&amp;rsquo;ve written a section of the code that
is controlled by preprocessor options then you should return this
error message if someone attempts to set input deck elements which refer to
that part when the correct preprocessor options are not used. This means that
the user is aware of the fact that the requested feature will not be
active. This error code also uses the extended error string to give user
friendly feedback. If you return this error code, you should set the string
extended_error_string to the define command that would turn on the
requested feature of the code (&amp;quot;-DPER_PARTICLE_WEIGHT&amp;quot;, for example).&lt;/li>
&lt;li>&lt;code>c_err_other&lt;/code> - This error code is a catch all error which causes
the code to quit with a sarcastic error message. It&amp;rsquo;s mainly intended for
debugging and is used before the final error code is implemented.&lt;/li>
&lt;/ul></description></item><item><title>String Handling</title><link>/developer/input_output/string_handling.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/developer/input_output/string_handling.html</guid><description>&lt;p>Fortran is not a language famous for its string handling capabilities, but due
to the presence of the input deck EPOCH has fairly extensive string handling
routines. Strings used are all of the standard Fortran &lt;code>CHARACTER&lt;/code>
type and are defined as:&lt;/p>
&lt;pre>&lt;code class="language-perl">CHARACTER(LEN=string_length) :: string
&lt;/code>&lt;/pre>
&lt;p>&lt;code>string_length&lt;/code> is a global constant defined in
&lt;code>src/constants.F90&lt;/code> which can be increased to allow EPOCH to
handle longer strings. There may be reasons to increase this length if you wish
to use long complex expressions in the input deck. Note that many Fortran
compilers do not allow strings to exceed 512 characters in length.&lt;/p>
&lt;p>Listed here are the string handling routines (other than those in the core
maths parser routine which are documented elsewhere) which are currently used
in EPOCH. These functions can be found in &lt;code>src/deck/strings.f90&lt;/code> and
&lt;code>src/deck/strings_advanced.f90&lt;/code>&lt;/p>
&lt;h2 id="str_cmp">str_cmp&lt;/h2>
&lt;pre>&lt;code class="language-perl">FUNCTION str_cmp(str_in, str_test)
CHARACTER(LEN=*), INTENT(IN) :: str_in, str_test
LOGICAL :: str_cmp
&lt;/code>&lt;/pre>
&lt;p>&lt;code>str_cmp&lt;/code> is the routine which does all the string comparisons in
EPOCH. It deals with leading and trailing whitespace automatically and
tests for length differences. It does not test for strings being
valid substrings of each other, only for full equality.&lt;/p>
&lt;p>A developer should always use &lt;code>str_cmp&lt;/code> rather than doing their own
string testing to ensure consistent behaviour across the entire EPOCH code
base.&lt;/p>
&lt;h2 id="as_real_simple">as_real_simple&lt;/h2>
&lt;pre>&lt;code class="language-perl">FUNCTION as_real_simple(str_in, err)
CHARACTER(LEN=*), INTENT(IN) :: str_in
INTEGER, INTENT(INOUT) :: err
REAL(num) :: as_real_simple
&lt;/code>&lt;/pre>
&lt;p>&lt;code>as_real_simple&lt;/code> is a routine to convert a string into a real
number without invoking the maths parser. It can cope with standard form as
well as simple decimal reals. It is significantly faster than the maths parser,
but should only be used when the user explicitly &lt;em>shouldn&amp;rsquo;t&lt;/em> be able to use
a mathematical expression. If the string cannot be parsed then the routine sets
the bitmask &lt;code>c_err_bad_value&lt;/code> on the parameter &lt;code>err&lt;/code>&lt;/p>
&lt;p>If you have a string which has to be converted into a real quickly then this is
the routine to use. You probably shouldn&amp;rsquo;t use it when parsing a string from
the input deck, since there is no reason to restrict the user from specifying a
mathematical expression. The routine is used inside the maths parser to parse
simple numbers.&lt;/p>
&lt;h2 id="as_integer_simple">as_integer_simple&lt;/h2>
&lt;pre>&lt;code class="language-perl">FUNCTION as_integer_simple(str_in, err)
CHARACTER(LEN=*), INTENT(IN) :: str_in
INTEGER, INTENT(INOUT) :: err
INTEGER :: as_integer_simple
&lt;/code>&lt;/pre>
&lt;p>&lt;code>as_integer_simple&lt;/code> is a routine to convert a string into an
integer without invoking the maths parser. It can cope with standard form as
well as simple decimal integers. It is significantly faster than the maths
parser, but should only be used when the user explicitly &lt;em>shouldn&amp;rsquo;t&lt;/em> be
able to use a mathematical expression. If the string cannot be parsed then the
routine sets the bitmask &lt;code>c_err_bad_value&lt;/code> on the parameter
&lt;code>err&lt;/code>&lt;/p>
&lt;p>This routine is used internally in several parts of the code when parsing
things like numbers which are parts of strings (i.e. the 1 in
&lt;code>direction1&lt;/code> for distribution functions). It probably shouldn&amp;rsquo;t
be used to directly parse input deck parameters, since there is no reason to
restrict the user from specifying mathematical expressions.&lt;/p>
&lt;h2 id="as_long_integer_simple">as_long_integer_simple&lt;/h2>
&lt;pre>&lt;code class="language-perl">FUNCTION as_long_integer_simple(str_in, err)
CHARACTER(LEN=*), INTENT(IN) :: str_in
INTEGER, INTENT(INOUT) :: err
INTEGER(KIND=8) :: as_long_integer_simple
&lt;/code>&lt;/pre>
&lt;p>&lt;code>as_long_integer_simple&lt;/code> is equivalent to
&lt;code>as_integer_simple&lt;/code>, but returns the larger
&lt;code>INTEGER(KIND=8)&lt;/code> rather than a normal &lt;code>INTEGER(KIND=4)&lt;/code>.&lt;/p>
&lt;h2 id="as_boundary">as_boundary&lt;/h2>
&lt;pre>&lt;code class="language-perl">FUNCTION as_boundary(str_in, err)
CHARACTER(LEN=*), INTENT(IN) :: str_in
INTEGER, INTENT(INOUT) :: err
INTEGER :: as_boundary
&lt;/code>&lt;/pre>
&lt;p>&lt;code>as_direction&lt;/code> is used when assigning a laser to a boundary and
recognises the strings&lt;/p>
&lt;ul>
&lt;li>x_min or left - c_bd_x_min.&lt;/li>
&lt;li>x_max or right - c_bd_x_max.&lt;/li>
&lt;li>y_min or down - c_bd_y_min.&lt;/li>
&lt;li>y_max or up - c_bd_y_max.&lt;/li>
&lt;li>z_min or back - c_bd_z_min.&lt;/li>
&lt;li>z_max or front - c_bd_z_max.&lt;/li>
&lt;/ul>
&lt;p>It returns the associated direction code (given after the dash in the
definition).&lt;/p>
&lt;p>If you&amp;rsquo;re writing code which requires attaching something to a boundary,
whether a boundary condition, a diagnostic or some other routine, then this is
the routine that should be used. Note that in order to prevent confusion when
moving input decks between different dimension versions of EPOCH, each code
only recognises the strings for boundaries that it actually has.&lt;/p>
&lt;h2 id="as_logical">as_logical&lt;/h2>
&lt;pre>&lt;code class="language-perl">FUNCTION as_logical(str_in, err)
CHARACTER(LEN=*), INTENT(IN) :: str_in
INTEGER, INTENT(INOUT) :: err
Logical :: as_logical
&lt;/code>&lt;/pre>
&lt;p>&lt;code>as_logical&lt;/code> simply tests for the strings &amp;ldquo;T&amp;rdquo; and &amp;ldquo;F&amp;rdquo; to
determine a boolean value. The default behaviour of &lt;code>as_logical&lt;/code> is
to treat any string that isn&amp;rsquo;t &amp;ldquo;T&amp;rdquo; as a false value.&lt;/p>
&lt;p>You should use this rather than using a 0/1 boolean flag in the input deck for
consistency.&lt;/p>
&lt;h2 id="split_off_int">split_off_int&lt;/h2>
&lt;pre>&lt;code class="language-perl">SUBROUTINE split_off_int(str_in, str_out, int_out, err)
CHARACTER(LEN=*), INTENT(IN) :: str_in
CHARACTER(LEN=*), INTENT(OUT) :: str_out
INTEGER, INTENT(OUT) :: int_out
INTEGER, INTENT(INOUT) :: err
&lt;/code>&lt;/pre>
&lt;p>&lt;code>split_off_int&lt;/code> is a routine which splits a string of the format
&lt;code>string n&lt;/code> into a string &lt;code>string&lt;/code> and an integer &lt;code>n&lt;/code> which are
returned separately in the &lt;code>str_out&lt;/code> and &lt;code>int_out&lt;/code>
parameters respectively. If it can&amp;rsquo;t split the string successfully then it
sets the &lt;code>c_err_bad_value&lt;/code> bitfield of the err parameter.&lt;/p>
&lt;p>This is used in the core of the deck parser to deal with blocks like the
numbered species blocks in the initial conditions, and also in some of the
specific block parsers. Again, this routine should be used to split strings
like this rather than coding a new routine.&lt;/p>
&lt;h2 id="split_range">split_range&lt;/h2>
&lt;pre>&lt;code class="language-perl">SUBROUTINE split_range(str_in, real1, real2, err)
CHARACTER(LEN=*), INTENT(IN) :: str_in
REAL(num), INTENT(OUT) :: real1, real2
INTEGER, INTENT(INOUT) :: err
&lt;/code>&lt;/pre>
&lt;p>&lt;code>split_range&lt;/code> is a routine which splits a string of the format
&lt;code>(n, m)&lt;/code> into two reals &lt;code>n&lt;/code> and &lt;code>m&lt;/code> which are returned
separately in the &lt;code>real1&lt;/code> and &lt;code>real2&lt;/code> parameters
respectively. If it can&amp;rsquo;t split the string successfully then it sets the
&lt;code>c_err_bad_value&lt;/code> bitfield of the err parameter.&lt;/p>
&lt;p>This is used when specifying ranges in the input decks at present. Any
ranges which should be specified in a single parameter should be specified in
this form and this routine used to split the string.&lt;/p>
&lt;h2 id="as_integer">as_integer&lt;/h2>
&lt;pre>&lt;code class="language-perl">FUNCTION as_integer(str_in, err)
CHARACTER(LEN=*), INTENT(IN) :: str_in
INTEGER, INTENT(INOUT) :: err
INTEGER :: as_integer
&lt;/code>&lt;/pre>
&lt;p>&lt;code>as_integer&lt;/code> is the routine which returns integers from strings
using the maths parser. If a mathematical expression resolves to a non-integer
result then this routine rounds to the NEAREST integer. There are explicit
rounding routines in the maths parser to force other behaviour.&lt;/p>
&lt;p>This routine should be used when evaluating most strings into integers. Note
that this routine evaluates spatially dependent quantities at (0,0) on each
processor, so will give unpredictable results when spatially dependent
quantities are given to it (like density, bx etc.). To evaluate a spatially
varying quantity use &lt;code>evaluate_string_in_space&lt;/code>.&lt;/p>
&lt;h2 id="as_long_integer">as_long_integer&lt;/h2>
&lt;pre>&lt;code class="language-perl">FUNCTION as_long_integer(str_in, err)
CHARACTER(LEN=*), INTENT(IN) :: str_in
INTEGER, INTENT(INOUT) :: err
INTEGER(KIND=8) :: as_long_integer
&lt;/code>&lt;/pre>
&lt;p>&lt;code>as_long_integer&lt;/code> is the routine which returns long integers from
strings using the maths parser. If a mathematical expression resolves to a
non-integer result then this routine rounds to the NEAREST integer. There are
explicit rounding routines in the maths parser to force other behaviour.&lt;/p>
&lt;p>This routine should be used when evaluating strings which are likely to be too
large to be stored in an INTEGER(KIND=4).&lt;/p>
&lt;h2 id="as_real">as_real&lt;/h2>
&lt;pre>&lt;code class="language-perl">FUNCTION as_real(str_in, err)
CHARACTER(LEN=*), INTENT(IN) :: str_in
INTEGER, INTENT(INOUT) :: err
REAL(num) :: as_real
&lt;/code>&lt;/pre>
&lt;p>&lt;code>as_real&lt;/code> is the routine which returns reals from strings using the
maths parser.&lt;/p>
&lt;p>This routine should be used when evaluating most strings into reals. Note that
this routine evaluates spatially dependent quantities at (0,0) on each
processor, so will give unpredictable results when spatially dependent
quantities are given to it (like density, bx etc.). To evaluate a spatially
varying quantity use &lt;code>evaluate_string_in_space&lt;/code>.&lt;/p>
&lt;h2 id="evaluate_string_in_space">evaluate_string_in_space&lt;/h2>
&lt;pre>&lt;code class="language-perl">SUBROUTINE evaluate_string_in_space(str_in, data_out, &amp;amp;
x1, x2, \{y1, y2, z1, z2,\} err)
CHARACTER(*), INTENT(IN) :: str_in
INTEGER, INTENT(INOUT) :: err
INTEGER, INTENT(IN) :: x1, x2\{, y1, y2, z1, z2\}
REAL(num), DIMENSION(1:,1:,1:), INTENT(OUT) :: data_out
&lt;/code>&lt;/pre>
&lt;p>&lt;code>evaluate_string_in_space&lt;/code> is a routine which is used to evaluate
a tokenized maths expression over a region of the domain. The dimensionality of
&lt;code>data_out&lt;/code>, and the presence or absence of &lt;code>y1, y2&lt;/code> and
&lt;code>z1, z2&lt;/code> depend on the dimensionality of the code being used. The
&lt;code>x1, x2, ...&lt;/code> parameters represent the indices in that
direction over which the expression should be evaluated. For example, in 2D to
evaluate an expression over the entire domain, the code would look like:&lt;/p>
&lt;pre>&lt;code class="language-perl">REAL(num), DIMENSION(:,:), ALLOCATABLE :: data
ALLOCATE(data(-2:nx+3,-2:ny+3))
CALL evaluate_string_in_space(string, data, -2, nx+3, -2, ny+3, err)
&lt;/code>&lt;/pre>
&lt;p>This routine is suitable to evaluate expressions over a subsection or all of
the domain, and is used in this way in the initial condition deck parser
routines. However, the routine does have one significant weakness, which is
that it tokenizes the string each time it is called. Tokenizing the string is a
time consuming process, so if the string is to be evaluated several times for
different reasons (for example, the time profile for the laser) then a
different procedure should be followed using the lower level parser routines.&lt;/p></description></item></channel></rss>