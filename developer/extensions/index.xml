<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Extending EPOCH | EPOCH</title><link>/developer/extensions.html</link><atom:link href="/developer/extensions/index.xml" rel="self" type="application/rss+xml"/><description>Extending EPOCH</description><generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><image><url>/images/logo_hub4b4d6a0f57638acebb5550a80c8c030_9243_300x300_fit_lanczos_2.png</url><title>Extending EPOCH</title><link>/developer/extensions.html</link></image><item><title>Input Deck</title><link>/developer/extensions/input_deck.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/developer/extensions/input_deck.html</guid><description>&lt;p>While using the &lt;code>custom_deck&lt;/code> subroutine is a good way of passing
parameters into the code or for temporary additions, it is not suitable for
permanent additions to the code. Adding new blocks to the code permanently is
very similar to doing it temporarily, but requires changes to some of the
subroutines in &lt;code>deck.F90&lt;/code>.&lt;/p>
&lt;p>There are six subroutines which may need to be changed to add new blocks to
the deck. These are&lt;/p>
&lt;ul>
&lt;li>&lt;code>deck_initialise&lt;/code> - Called before parsing of the input
deck is begun.&lt;/li>
&lt;li>&lt;code>deck_finalise&lt;/code> - Called after parsing of the input
deck is complete.&lt;/li>
&lt;li>&lt;code>start_block(block_name)&lt;/code> - Called when the deck directive
&lt;code>begin:block_name&lt;/code> appears in a deck file.&lt;/li>
&lt;li>&lt;code>end_block(block_name)&lt;/code> - Called when the deck directive
&lt;code>end:block_name&lt;/code> appears in a deck file.&lt;/li>
&lt;li>&lt;code>handle_block(block_name, block_element, block_value)&lt;/code> -
Called once for each element in a block.&lt;/li>
&lt;li>&lt;code>check_compulsory_blocks(errcode_deck)&lt;/code> - Called once when
the deck file has been read to check that all necessary blocks have been
populated.&lt;/li>
&lt;/ul>
&lt;p>There is one final variable which is important for modifying the input deck,
&lt;code>deck_state&lt;/code>. The input deck parser routine used to read the main
input deck uses the variable &lt;code>deck_state&lt;/code> to
determine which stage of parsing the deck is required. The possible values of
&lt;code>deck_state&lt;/code> are&lt;/p>
&lt;ul>
&lt;li>c_ds_first - The first pass through the deck, before memory has been
allocated.&lt;/li>
&lt;li>c_ds_last - After the initial deck pass, all arrays and lists are
allocated. The deck is then parsed a final time so that allocated memory
can be populated with initial conditions.&lt;/li>
&lt;/ul>
&lt;p>These constants are defined in &lt;code>shared_data.F90&lt;/code>.&lt;/p>
&lt;p>The layout of &lt;code>deck_initialise&lt;/code> and &lt;code>deck_finalise&lt;/code> is
extremely simple. They just call &lt;code>*_deck_initialise&lt;/code> or
&lt;code>*_deck_finalise&lt;/code> for each of the possible block types.
&lt;code>start_block&lt;/code> and &lt;code>end_block&lt;/code> are also fairly
straightforward. They examine the block name and call the
&lt;code>*_block_start&lt;/code> or &lt;code>*_block_end&lt;/code> routine
corresponding to the current block.&lt;/p>
&lt;p>The &lt;code>handle_block&lt;/code> routine acts in a similar manner except
that it also does some error handling.
At the simplest level the routine simply calls another function which
takes the block_element and block_value as
parameters and returns an error code
determining the success or failure of reading the element.&lt;/p>
&lt;p>The final routine is &lt;code>check_compulsory_blocks&lt;/code> which is used to
check that all the needed elements of the input deck have been set. A single
parameter &lt;code>errcode_deck&lt;/code> is passed in. The routine
checks &lt;code>deck_state&lt;/code> to make sure that it is the last pass
through the deck. It then goes through and calls functions to check that
all the necessary parts of a block have been set. The subroutines are contained
in the same file as the routine which is called in &lt;code>handle_block&lt;/code> to
handle elements of the block. The error handler functions should return an
error code, usually
&lt;code>c_err_missing_elements&lt;/code>. The
return code from the error handler function should then be &lt;code>IOR&lt;/code>-ed
with &lt;code>errcode_deck&lt;/code> to allow error codes to be returned from
several different checks with errors occurring.&lt;/p>
&lt;h2 id="the-element-handler-routines-for-deck-elements">The element handler routines for deck elements&lt;/h2>
&lt;p>The exact form of the handler routines is up to the end user. The only
&lt;em>requirements&lt;/em> are that the routine should return an error code detailing
whether or not there are any problems with reading the block and that the error
code should be &lt;code>c_err_none&lt;/code> if either the element name or element
value are the special constant &lt;code>blank&lt;/code>. The typical implementation
of an element handler routine is shown in the file
&lt;code>src/deck/deck_control_block.f90&lt;/code>, and this general layout should
be copied for compatibility if possible.&lt;/p>
&lt;p>Sometimes, it is useful to have each new block correspond to a new instance of
an object in the code. An example of this in EPOCH is in
&lt;code>src/deck/deck_laser_block.f90&lt;/code> where each new laser block in
the input deck corresponds to a new laser being attached to a boundary. This is
accomplished by implementing the lasers as a linked list on each boundary,
with a new laser object being created when a laser block is started, the laser
information being set during the main reader routine, and then the laser being
attached to the linked list by a call to &lt;code>attach_laser&lt;/code> in
&lt;code>src/laser.f90&lt;/code> when the block is ended. When a new laser block is
started the process simply repeats allowing the end user to have as many lasers
as desired.&lt;/p>
&lt;h2 id="adding-elements-to-existing-blocks">Adding elements to existing blocks&lt;/h2>
&lt;p>The existing blocks in the code are read in the files listed in \sect{src_deck}&lt;/p>
&lt;p>The existing structure of the blocks is simple enough in most cases that it
should be fairly easy to add new elements if needed. The most likely change
needed is to change the list of variables to dump in the &lt;code>output&lt;/code>
block. How to do this is detailed in \sect{io}.&lt;/p></description></item><item><title>Maths Parser</title><link>/developer/extensions/maths_parser.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/developer/extensions/maths_parser.html</guid><description>&lt;p>When an extension is intended for a new release, the temporary custom extensions
are not appropriate. In these cases, it is possible to permanently add functions
and constants to
EPOCH&amp;rsquo;s maths parser. Although adding new operators is possible, it is
sufficiently likely to cause problems with the operation of the maths parser
that it is formally not recommended by the author of the program, and hence is
not documented here.&lt;/p>
&lt;h2 id="adding-the-new-tokenizer-handle">Adding the new tokenizer handle&lt;/h2>
&lt;p>When adding a new function or constant to the maths parser using the temporary
routines, there are two calls (&lt;code>register_function&lt;/code> and
&lt;code>register_constant&lt;/code>) which give a numerical handle. This is the
token used to represent that function or constant after the text has been parsed
(remember that EPOCH&amp;rsquo;s maths parser tokenizes before evaluation!). When
permanently adding objects to the maths parser, the tokenizer handles have to
be set up manually. This takes place in &lt;code>src/shared_data.F90&lt;/code> in
the module &lt;code>shared_parser_data&lt;/code>. There are several lines which
look like:&lt;/p>
&lt;pre>&lt;code class="language-perl"> INTEGER, PARAMETER :: c_const_ix = 40
INTEGER, PARAMETER :: c_const_iy = 41
.
.
.
INTEGER, PARAMETER :: c_func_interpolate = 22
INTEGER, PARAMETER :: c_func_tanh = 23
&lt;/code>&lt;/pre>
&lt;p>Constants beginning with &lt;code>c_const_&lt;/code> are tokenizer handles for
constants, and those beginning with &lt;code>c_func_&lt;/code> are tokenizer handles
for functions. Each number must be unique and has to be less than
the lower bound of values reserved for temporary or deck
specified values. This means that any tokenizer handle for a function has to be
less than the value of the variable &lt;code>c_func_custom_lowbound&lt;/code> and
any handle for a constant must be less than
&lt;code>c_const_deck_lowbound&lt;/code>. It is acceptable to simply increase the
value of &lt;code>c_func_custom_lowbound&lt;/code> and
&lt;code>c_const_deck_lowbound&lt;/code> to
allow the use of more values for internal constants and functions, although
care should be taken since this could lead to performance issues.
If &lt;code>c_const_deck_lowbound&lt;/code> is increased then the constant
&lt;code>c_constant_custom_lowbound&lt;/code> should be increased by the same
amount (the values between &lt;code>c_const_deck_lowbound&lt;/code> and
&lt;code>c_constant_custom_lowbound-1&lt;/code> are used for constants specified
inside the input deck while values greater than or equal to
&lt;code>c_constant_custom_lowbound&lt;/code> are used for constants specified
by &lt;code>register_constant&lt;/code>.&lt;/p>
&lt;p>Once the tokenizer handle is specified in &lt;code>shared_parser_data&lt;/code>, it
is now possible to extend the main areas of the maths parser. Note that from
here on, you MUST always use the constant named handle, NEVER the numerical
value that you specified for the value of the handle. If this is not done
then combining functions and constants from several sources becomes much harder.&lt;/p>
&lt;h2 id="adding-the-new-function-or-constant-to-the-tokenizer">Adding the new function or constant to the tokenizer&lt;/h2>
&lt;p>The next stage is to add the string representation of your constant or function
to the tokenizer routines in
&lt;code>src/parser/tokenizer_blocks.f90&lt;/code>. This is very simple to do, just
find either the function &lt;code>as_constant&lt;/code> or &lt;code>as_function&lt;/code>
and look at the existing code. These functions are just long lists of
&lt;code>str_cmp&lt;/code> commands followed by code to deal with custom
functions/constants. To add the new code, create an additional line such as:&lt;/p>
&lt;pre>&lt;code class="language-perl"> IF (str_cmp(name, &amp;quot;my_const&amp;quot;)) as_constant = c_const_my_const
.
.
.
IF (str_cmp(name, &amp;quot;my_func&amp;quot;)) as_function = c_func_my_func
&lt;/code>&lt;/pre>
&lt;p>Note that neither routine returns immediately after recognising the name of the
function/constant. This allows users to override built in constants or
functions with custom versions using &lt;code>register_constant}&lt;/code>
and &lt;code>register_function&lt;/code>. This is not significant, since tokenizing
should never be used in a speed critical part of the code.&lt;/p>
&lt;h2 id="implementing-the-function-or-constant-in-the-evaluator">Implementing the function or constant in the evaluator&lt;/h2>
&lt;p>The evaluator is the part of the code that actually takes the streams of tokens
produced by the tokenizer and evaluates them into a number. The relevant parts
of the evaluator for adding new constants or functions are in
&lt;code>src/parser/evaluator_blocks.f90&lt;/code> and the functions which may need
changing are &lt;code>do_constant&lt;/code> and &lt;code>do_functions&lt;/code>. These are
both passed up to five parameters:&lt;/p>
&lt;ul>
&lt;li>&lt;code>INTEGER :: opcode&lt;/code> - The operation code, this is the tokenizer handle
which was defined in &lt;code>shared_parser_data&lt;/code>.&lt;/li>
&lt;li>&lt;code>INTEGER :: ix, iy, iz&lt;/code> - The position of the current evaluation in the
domain. If your function or constant behaves differently at different points
in space then you should use these parameters to reference the correct point
of an array.&lt;/li>
&lt;li>&lt;code>INTEGER :: errcode&lt;/code> - This should be set to an error code, usually
&lt;code>c_err_bad_value&lt;/code> if for some reason it is not possible to evaluate your
constant or function.&lt;/li>
&lt;/ul>
&lt;p>The rest of the routine to set a constant is as simple as testing for the
tokenizer handle already set up in &lt;code>shared_parser_data&lt;/code> and then
calling the subroutine &lt;code>push_on_eval&lt;/code>. This pushes the final
constant onto the evaluation stack which is used by the RPN parser. The basic
sequence for functions is similar except for the addition of a code to read
the values that the function takes. This is again the subroutine
&lt;code>get_values&lt;/code> which is also used in custom_function. The calling
sequence in &lt;code>do_function&lt;/code> looks like:&lt;/p>
&lt;pre>&lt;code class="language-perl"> IF (opcode .EQ. c_func_gauss) THEN
CALL get_values(3, values)
CALL push_on_eval(EXP(-((values(1)-values(2))/values(3))**2))
RETURN
ENDIF
&lt;/code>&lt;/pre>
&lt;p>Simply call the &lt;code>get_values&lt;/code> subroutine, passing the number of
required parameters and an array of type &lt;code>REAL(num)&lt;/code> which is at
least as long as the number of required parameters. The array is populated
by the values passed into the function. Constants and maths expressions are
already evaluated by the time that this section of code is reached, so there is
no need to deal with further parsing. Next, simply call
&lt;code>push_on_eval&lt;/code> to push the result of your function onto the
evaluation stack.&lt;/p></description></item><item><title>New Module</title><link>/developer/extensions/new_modules.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/developer/extensions/new_modules.html</guid><description>&lt;p>Adding a new module or physics package can turn out to be a very complicated
process, but plugging it into the existing PIC-loop is usually quite
straightforward. In this page, we will assume you have the source-code for a new
module, and we will explain how to add it to EPOCH&amp;rsquo;s calculations.&lt;/p>
&lt;h2 id="the-main-driver-routine">The main driver routine&lt;/h2>
&lt;p>When adding completely new routines to the code, they should be added to the
file &lt;code>src/epochnd.F90&lt;/code>. This routine simply calls other routines
to perform the actual execution of the code. The first section of the code
controls basic setup, MPI initialisation and
initial conditions. If you wish to add new startup conditions then
you should find the location in this routine where the
initial conditions are setup. The code is fairly complicated, but
there are a few key points at which the code significantly changes state.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>After the call to &lt;code>read_deck&lt;/code> the code has read the basic
information from the input deck files and any tests or changes which have to
be made to input deck values should be made immediately after this line. Note
that although the variables from the deck have been set,
none of these values have been used so allocatable
variables have yet to be allocated. The grid does not exist at this point.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>After the call to &lt;code>open_files&lt;/code> the code has finished
allocating all field variables, although particles may not yet have been set
up. The grid now exists.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>There are now a series of &lt;code>IF&lt;/code> statements which test for
things like &lt;code>IF (IOR(ictype, c_ic_autoload) .NE. 0)&lt;/code>.
These are the lines which test for all possible states of the
initial conditions. The last test is for the manual load routine
(&lt;code>c_ic_manual&lt;/code>). After this test all the particles have been
loaded and are now on their correct processor. The load balancer has now been
called at least once so the domains may no longer be identical.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The main loop is a simple do loop beginning with just the single command
&lt;code>DO&lt;/code>. Inside this loop there are several calls to routines which
actually advance the system. Most routines which can change currents should
take place after the particle pusher but before the final update for the $E$
and $B$ fields. These routines are&lt;/p>
&lt;ul>
&lt;li>&lt;code>set_dt&lt;/code> - This routine sets the timestep.&lt;/li>
&lt;li>&lt;code>update_eb_fields_half&lt;/code> - Time centre the $E$ and $B$
fields.&lt;/li>
&lt;li>&lt;code>push_particles&lt;/code> - The particle pusher.&lt;/li>
&lt;li>&lt;code>reorder_particles_to_grid&lt;/code> - Groups particles into
linked lists at each grid point. Used for the particle splitting routine,
and binary collisions. Any routine
which needs to have nearby particles grouped together should take place
after the call to this routine.&lt;/li>
&lt;li>&lt;code>split_particles&lt;/code> - The particle
splitting operator.&lt;/li>
&lt;li>&lt;code>reattach_particles_to_mainlist&lt;/code> - Undoes the
particle grouping and rebuilds the main list of particles used by the
particle pusher. Any routine which needs to have nearby particles grouped
together should take place before the call to this routine.&lt;/li>
&lt;li>&lt;code>update_eb_fields_final&lt;/code> - Updates the $E$ and $B$
fields to the full timestep.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>After the call to &lt;code>update_eb_fields_final&lt;/code> the code is
ready for another timestep. Any routines which do not change the time
integrated properties of the code (like the moving window) should come after
this call.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="the-particle-reordering-routine">The particle reordering routine&lt;/h2>
&lt;p>After &lt;code>reorder_particles_to_grid&lt;/code>, the particles have been moved to
particle-lists unique to each cell. The main list
&lt;code>species(ispecies)%attached_list&lt;/code> is empty and cannot be used
during this period. The particles should now be accessed using the variable
&lt;code>species(ispecies)%secondary_list(ix,iy,iz)&lt;/code> which is the array of
linked lists. This array is allocated on the call to
&lt;code>reorder_particles_to_grid&lt;/code> and deallocated on the call to
&lt;code>reattach_particles_to_mainlist&lt;/code>, and should not be used outside
the section of code between these two calls. The particles themselves remain
unchanged. No attempt is made to check that particles do not cross processor
boundaries in this section, so if a particle&amp;rsquo;s position is changed, it is up to
the user to ensure that the particle is transferred to another processor if
required. However, if a particle is transferred to another processor, it is
acceptable to relink it to &lt;code>species(ispecies)%attached_list&lt;/code> since
the other lists are simply appended to that list when the particles are
reattached to the main list.&lt;/p>
&lt;p>You should avoid using these routines if possible, as they have a significant
impact on performance. However, this remains the best method for cycling through
processes which require particles to interact with other particles within the
same cell, such as collisions or collisional ionisation. It is likely that new
physics modules for two-body interactions between incident and target particles
will also need to use this method (especially if the target particle changes).&lt;/p></description></item><item><title>New Particle Variable</title><link>/developer/extensions/new_particle_variable.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/developer/extensions/new_particle_variable.html</guid><description>&lt;p>Sometimes you may wish to output a new variable associated with a
particle. Such extensions may be specific to a
particular task, and may be too niche to be added to the core EPOCH code.
Alternatively, users may wish to quickly add new particle variables, without
submitting a request to the developers and waiting for a new release. This
section will detail how to define a new particle variable, and how to dump it
to SDF files.&lt;/p>
&lt;p>There are multiple parts of the code which need to be modified to create and print
a new particle variable, these are:&lt;/p>
&lt;ul>
&lt;li>&lt;code>Makefile&lt;/code>: New pre-compiler option to deactivate new variable when not needed (for speed)&lt;/li>
&lt;li>&lt;code>shared_data.F90&lt;/code>: Give the particle datatype a new variable&lt;/li>
&lt;li>&lt;code>housekeeping/welcome.F90&lt;/code>: Alert the user when the code is compiled with your new option&lt;/li>
&lt;li>&lt;code>housekeeping/partlist.F90&lt;/code>: As particles move between MPI ranks, move your new variable with them&lt;/li>
&lt;li>&lt;code>constants.F90&lt;/code>: Create tags for the new output and compiler flag&lt;/li>
&lt;li>&lt;code>deck/deck_io_block.F90&lt;/code>: Lets the output block see the new output variable&lt;/li>
&lt;li>&lt;code>io/diagnostics.F90&lt;/code>: Writes the new variable to the SDF file&lt;/li>
&lt;li>&lt;code>io/iterators.F90&lt;/code>: Gives diagnostics.F90 variables to write to file&lt;/li>
&lt;li>&lt;strong>Extra&lt;/strong>: The user should set the value of the new variable to something&lt;/li>
&lt;/ul>
&lt;p>On this page, we provide an example of how to add and output a new particle
variable, which has actually been requested by an EPOCH user.
When electrons emit photons in the QED package, the photon macro-particle
contains no information about the electron which generated it. In this
example, let us output the Lorentz $\gamma$ factor of the radiating electron
for each emitted photon, at the time of photon emission. We will use EPOCH2D,
although this methodology would work for any dimension of the code. In these
examples, we will include some of the neighbouring lines of code, so you can
get a sense of where to insert the new code for your variable.&lt;/p>
&lt;h2 id="makefile">Makefile&lt;/h2>
&lt;p>We want a new pre-compiler flag for the new addition. As macro-particles move
around the simulation, they are passed between MPI ranks. The more particle
variables to transfer, the slower the code runs. Hence, if we don&amp;rsquo;t need to use
the new particle variables, the code should be compiled without them. This
is achieved with new pre-compiler variables.&lt;/p>
&lt;p>In the Makefile, there is a section with multiple commented-out pre-compiler
flags. Let us add a new one called &amp;ldquo;extended_io&amp;rdquo;. To do this, insert a line
such that the Makefile reads like:&lt;/p>
&lt;pre>&lt;code># Use second order particle weighting (default is third order).
#DEFINES += $(D)PARTICLE_SHAPE_TOPHAT
# Use fifth order particle weighting (default is third order).
#DEFINES += $(D)PARTICLE_SHAPE_BSPLINE3
# Include a unique global particle ID. The first flag defines the ID using
# an 8-byte integer, the second uses 4-bytes.
#DEFINES += $(D)PARTICLE_ID
#DEFINES += $(D)PARTICLE_ID4
# Include QED routines
DEFINES += $(D)PHOTONS
# Extended I/O for QED routines
DEFINES += $(D)EXTENDED_IO
# Use the Trident process for pair production
#DEFINES += $(D)TRIDENT_PHOTONS
# Include bremsstrahlung routines
#DEFINES += $(D)BREMSSTRAHLUNG
&lt;/code>&lt;/pre>
&lt;p>Note that we have un-commented the new extended_io flag, and the photons flag,
as we will have to run the code with both for the new output in this example.&lt;/p>
&lt;h2 id="constantsf90">Constants.F90&lt;/h2>
&lt;p>Let us make new global integer flags for both the pre-compiler flag, and the
new output.&lt;/p>
&lt;p>For the &lt;code>EXTENDED_IO&lt;/code> pre-compiler flag, find the &lt;code>c_def...&lt;/code> list and append a
new &lt;code>c_def_extended_io&lt;/code> variable to the end:&lt;/p>
&lt;pre>&lt;code> INTEGER(i8), PARAMETER :: c_def_use_mpi3 = 2**25
INTEGER(i8), PARAMETER :: c_def_bremsstrahlung = 2**26
INTEGER(i8), PARAMETER :: c_def_probe_time = 2**27
INTEGER(i8), PARAMETER :: c_def_extended_io = 2**28 ! New line
&lt;/code>&lt;/pre>
&lt;p>Next, let us make a new output flag: &lt;code>c_dump_qed_el_gamma&lt;/code>. Find the list of
&lt;code>c_dump...&lt;/code> parameters, and add our new one to the end. Remember to update the
&lt;code>num_vars_to_dump&lt;/code> variable with the new number of dump flags.&lt;/p>
&lt;pre>&lt;code> INTEGER, PARAMETER :: c_dump_probe_time = 72
INTEGER, PARAMETER :: c_dump_cou_log = 73
INTEGER, PARAMETER :: c_dump_qed_el_gamma = 74 ! New line
INTEGER, PARAMETER :: num_vars_to_dump = 74 ! Modified line
&lt;/code>&lt;/pre>
&lt;p>Note, you may wish to introduce multiple outputs with one pre-compiler flag.
For example, the &lt;code>WORK_DONE_INTEGRATED&lt;/code> pre-compiler flag introduces &lt;em>six&lt;/em> new
outputs.&lt;/p>
&lt;h2 id="shared_dataf90">Shared_data.F90&lt;/h2>
&lt;p>Here we declare a new variable for the particle data-type. Be sure to wrap this
inside your new pre-compiler flag using &lt;code>#ifdef&lt;/code> commands (note these cannot be
indented - the first character of these lines must be &lt;code>#&lt;/code>). In our example, we
have called the new variable &lt;code>electron_gamma&lt;/code>.&lt;/p>
&lt;pre>&lt;code> ! Object representing a particle
! If you add or remove from this section then you *must* update the
! particle pack and unpack routines
TYPE particle
REAL(num), DIMENSION(3) :: part_p
REAL(num), DIMENSION(c_ndims) :: part_pos
#ifdef EXTENDED_IO
REAL(num) :: electron_gamma ! New line, and the surrounding ifdef, endif
#endif
&lt;/code>&lt;/pre>
&lt;h2 id="welcomef90">Welcome.F90&lt;/h2>
&lt;p>For consistency with the other EPOCH pre-compiler options, we should print a
message when the code has been compiled with our new &lt;code>EXTENDED_IO&lt;/code>.&lt;/p>
&lt;p>The first part of the module scans through all possible pre-compiler variables,
and checks if any are present. Add new lines for the new pre-compiler flag.&lt;/p>
&lt;pre>&lt;code>#ifdef PHOTONS
found = .TRUE.
#ifdef TRIDENT_PHOTONS
found = .TRUE.
#endif
#endif
#ifdef EXTENDED_IO
found = .TRUE. ! New line
#endif
&lt;/code>&lt;/pre>
&lt;p>Next, a message is printed for each present module. Here we have written a
generic message for our extended_io pre-compiler flag.&lt;/p>
&lt;pre>&lt;code>#ifdef PHOTONS
defines = IOR(defines, c_def_photons)
WRITE(*,*) 'QED Effects -DPHOTONS'
#ifdef TRIDENT_PHOTONS
defines = IOR(defines, c_def_trident_photons)
WRITE(*,*) 'Pair production by Trident process -DTRIDENT_PHOTONS'
#endif
#endif
#ifdef EXTENDED_IO
defines = IOR(defines, c_def_extended_io) ! New line
WRITE(*,*) 'Additional particle variables for output -DEXTENDED_IO' ! New line
#endif
&lt;/code>&lt;/pre>
&lt;h2 id="partlistf90">Partlist.F90&lt;/h2>
&lt;p>Each MPI rank only tracks particles present within its section of the domain.
As macro-particles move around the simulation, they can pass between cells
controlled by different ranks. When this happens, a new particle is created on
the new rank, its properties are set to match the properties on the old rank,
and the particle on the old rank is destroyed. New particle variables must
also be transferred when particles move between ranks, and this is done here.&lt;/p>
&lt;p>There are 4 steps here:&lt;/p>
&lt;ul>
&lt;li>Tell the code how many variables are associated with the particle&lt;/li>
&lt;li>Copy the variables on the old rank to an array for transfer&lt;/li>
&lt;li>Set variables on the new rank from the transferred array&lt;/li>
&lt;li>For new particles, initialise the particle variable&lt;/li>
&lt;/ul>
&lt;p>To tell the code how many variables are present, find the &lt;code>set_partlist_size&lt;/code>
subroutine. The count of particle variables is stored in the &lt;code>nvar&lt;/code> integer.
In this example, we only introduce one more particle variable when the code
is compiled with &lt;code>EXTENDED_IO&lt;/code>, so add 1 to &lt;code>nvar&lt;/code> if we have compiled with
&lt;code>EXTENEDED_IO&lt;/code>:&lt;/p>
&lt;pre>&lt;code>#ifdef BREMSSTRAHLUNG
nvar = nvar+1
#endif
#ifdef EXTENDED_IO
nvar = nvar+1 ! New line
#endif
#ifdef PROBE_TIME
nvar = nvar+1
#endif
&lt;/code>&lt;/pre>
&lt;p>Next, navigate to &lt;code>pack_particle&lt;/code> - the subroutine responsible for collecting
particle variables to transfer to neighbouring ranks. Now we can add our new
variable to the transfer array. Make a note of the position here - variables
must be read in the same order they are stored.&lt;/p>
&lt;pre>&lt;code>#ifdef BREMSSTRAHLUNG
array(cpos) = a_particle%optical_depth_bremsstrahlung
cpos = cpos+1
#endif
#ifdef EXTENDED_IO
array(cpos) = a_particle%electron_gamma ! New line
cpos = cpos+1 ! Only 1 new variable, so add 1
#endif
#ifdef PROBE_TIME
array(cpos) = a_particle%probe_time
cpos = cpos+1
#endif
&lt;/code>&lt;/pre>
&lt;p>Once the particle variables are packed into an array, this is sent to the
neighbouring ranks. These call &lt;code>unpack_particle&lt;/code> to set the properties of new
particles. The syntax for this with our new variable would be:&lt;/p>
&lt;pre>&lt;code>#ifdef BREMSSTRAHLUNG
a_particle%optical_depth_bremsstrahlung = array(cpos)
cpos = cpos+1
#endif
#ifdef EXTENDED_IO
a_particle%electron_gamma = array(cpos) ! New line
cpos = cpos+1 ! Note this is also between optical_depth_bremsstrahlung and probe_time
#endif
#ifdef PROBE_TIME
a_particle%probe_time = array(cpos)
cpos = cpos+1
#endif
&lt;/code>&lt;/pre>
&lt;p>Finally, we must set the initial values for these variables. If we don&amp;rsquo;t do
this, the code can act unpredictably. In the &lt;code>init_particle&lt;/code> subroutine, add
the lines:&lt;/p>
&lt;pre>&lt;code>#ifdef EXTENDED_IO
new_particle%electron_gamma = 0.0_num ! New line
#endif
#ifdef PROBE_TIME
new_particle%probe_time = 0.0_num
#endif
&lt;/code>&lt;/pre>
&lt;h2 id="deck_io_blockf90">Deck_io_block.F90&lt;/h2>
&lt;p>Unless you want to make a new physics package, a new particle variable is only
useful if you can output it. This is done using the standard EPOCH output block.
Recall we&amp;rsquo;ve already defined a &lt;code>c_dump_qed_el_gamma&lt;/code> flag - now we just need
to tell EPOCH how it will appear in the input deck.&lt;/p>
&lt;p>Navigate to &lt;code>io_block_handle_element&lt;/code>, find the &lt;code>str_cmp&lt;/code> lines which interpret
the the deck lines, and add:&lt;/p>
&lt;pre>&lt;code>#ifdef BREMSSTRAHLUNG
ELSE IF (str_cmp(element, 'bremsstrahlung_optical_depth')) THEN
elementselected = c_dump_part_opdepth_brem
#endif
#ifdef EXTENDED_IO
ELSE IF (str_cmp(element, 'electron_gamma')) THEN ! New line
elementselected = c_dump_qed_el_gamma ! New line
#endif
&lt;/code>&lt;/pre>
&lt;p>Whatever you write as the second argument to &lt;code>str_cmp&lt;/code> is how you will
have to write the variable in the EPOCH output block. As we are keeping things
simple in this example, we will not bother with restart dumps. The value of
&lt;code>electron_gamma&lt;/code> will not be re-loaded when you restart the code from a
restart dump.&lt;/p>
&lt;h2 id="diagnosticsf90">Diagnostics.F90&lt;/h2>
&lt;p>At this point we have declared a new particle variable, wrapped it in
pre-compiler flags, made it visible to MPI routines, and told EPOCH it can be
dumped. Now we actually have to write the variable to file.&lt;/p>
&lt;p>There is a section in the &lt;code>output_routines&lt;/code> subroutine which contains lines
with &lt;code>write_particle_variable&lt;/code> calls. Add a new one for our variable:&lt;/p>
&lt;pre>&lt;code>#ifdef BREMSSTRAHLUNG
CALL write_particle_variable(c_dump_part_opdepth_brem, code, &amp;amp;
'Bremsstrahlung Depth', '', it_output_real)
#endif
#ifdef EXTENDED_IO
CALL write_particle_variable(c_dump_qed_el_gamma, code, &amp;amp;
'Emitting Electron Gamma', '', it_output_real)
#endif
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>'Emitting Electron Gamma'&lt;/code> string controls how the variable will be
labelled in the SDF file.&lt;/p>
&lt;h2 id="iteratorsf90">Iterators.F90&lt;/h2>
&lt;p>One of the arguments of the &lt;code>write_particle_variable&lt;/code> subroutine is a call to
the &lt;code>it_output_real&lt;/code> function. We need to modify this function to give our new
variable, when requested. To do this, add the following case to the
&lt;code>it_output_real&lt;/code> function:&lt;/p>
&lt;pre>&lt;code>#ifdef EXTENDED_IO
CASE (c_dump_qed_el_gamma)
DO WHILE (ASSOCIATED(cur) .AND. (part_count &amp;lt; npoint_it))
part_count = part_count + 1
array(part_count) = cur%electron_gamma
cur =&amp;gt; cur%next
END DO
#endif
&lt;/code>&lt;/pre>
&lt;h2 id="setting-your-variable">Setting your variable&lt;/h2>
&lt;p>All the previous steps are required whatever your particle
variable is. All we need to do now is figure out how to set it. This may be
straightforward or complicated, depending on what the variable is. We can&amp;rsquo;t
cover every possible particle variable here, but you may find it useful if we
finish our example, to see how one would go about it.&lt;/p>
&lt;p>Here, we want to save the electron gamma factor when a photon has been emitted.
Photon emission occurs in the &lt;code>generate_photon&lt;/code> subroutine of &lt;code>photons.F90&lt;/code>.
When in this subroutine, the generating electron information can be accessed
through the &lt;code>generating_electron&lt;/code> particle pointer. Fortunately for us, the
electron $\gamma$ factor has already been calculated in this subroutine, and is
given by &lt;code>generating_gamma&lt;/code>. Let us set our new particle variable to this
value, as soon as the photon macro-particle has been created.&lt;/p>
&lt;pre>&lt;code> CALL create_particle(new_photon)
new_photon%part_pos = generating_electron%part_pos
#ifdef EXTENDED_IO
new_photon%electron_gamma = generating_gamma ! New line
#endif
&lt;/code>&lt;/pre>
&lt;h2 id="testing">Testing&lt;/h2>
&lt;p>If all has gone well, we have a new particle variable ready for printing.
Compile EPOCH (you may need to run &lt;code>make clean&lt;/code> first if you have changed the
pre-compiler flags).&lt;/p>
&lt;p>It&amp;rsquo;s best to run with a small input deck for code testing. We have shrank the
qed_rese.deck found in the source code, such that it can run in a few seconds.
This tiny deck has been included at the end of this section.&lt;/p>
&lt;p>When running, the code correctly generates the compiler-flag messages:&lt;/p>
&lt;pre>&lt;code> Welcome to EPOCH2D version 4.19.1 (commit v4.19.1-7-g6a1bfa99-dirty)
The code was compiled with the following compile time options
*************************************************************
QED Effects -DPHOTONS
Additional particle variables for output -DEXTENDED_IO
*************************************************************
&lt;/code>&lt;/pre>
&lt;p>When we inspect &lt;code>0001.sdf&lt;/code>, we find that 21798 macro-photons have been created,
and all of them have an emitting electron gamma value. These range from 20 to
1896 in this example. The input deck used for this example is given below. A
new particle variable has been successfully created!&lt;/p>
&lt;pre>&lt;code>begin:control
nx = 50 # in x
ny = 50
nparticles = nx * ny * 2
t_end = 100e-15
x_min = 0
x_max = 50 * 10.0e-9
y_min = 0
y_max = 50 * 10.0e-9
dt_multiplier = 0.8
end:control
begin:qed
use_qed = T
qed_start_time = 0
produce_photons = T
photon_energy_min = 50 * kev
produce_pairs = F
photon_dynamics = F
end:qed
begin:boundaries
bc_x_min = simple_laser
bc_x_max = reflect
bc_y_max = reflect
bc_y_min = reflect
end:boundaries
begin:species
name = Electron
fraction = 0.5
dump = T
temperature = 0
number_density = if (x gt 0.1*x_max, 1.0e20, 0)
identify:electron
end:species
begin:species
name = Ion
fraction = 0.5
dump = T
number_density = number_density(Electron)
temperature = 0
identify:proton
end:species
begin:species
name = Photon
frac = 0
dump = T
identify:photon
end:species
begin:output
dt_snapshot = t_end
electron_gamma = always
end:output
begin:laser
boundary = x_min
intensity = 1.0e21 * 1.0e4
lambda = 1.0e-6
polarisation = 0.0
phase = 0.0
t_profile = 1
profile = 1
end:laser
&lt;/code>&lt;/pre></description></item></channel></rss>